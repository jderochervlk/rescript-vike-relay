diff --git a/node_modules/rescript-relay/lib/bs/.bsbuild b/node_modules/rescript-relay/lib/bs/.bsbuild
new file mode 100644
index 0000000..2160283
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/.bsbuild
@@ -0,0 +1,14 @@
+10
+RescriptRelay
+ReactExperimental
+RescriptRelayUtils
+RescriptRelay_Query
+ReactDOMExperimental
+RescriptRelay_Fragment
+RescriptRelay_Internal
+RescriptRelay_Mutation
+RescriptRelay_Subscriptions
+RescriptRelay_RelayResolvers
+src	
+1
+0
diff --git a/node_modules/rescript-relay/lib/bs/.bsdeps b/node_modules/rescript-relay/lib/bs/.bsdeps
new file mode 100644
index 0000000..83eac2a
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/.bsdeps
@@ -0,0 +1,7 @@
+11.0.0-rc.4
+/home/josh/Dev/rescript-vike/node_modules/rescript-relay
+1 -bs-package-output es6:.:.mjs4Automatic
+bsconfig.json	0x1.94982a88f344p+30
+src	0x1.94982c72971bp+30
+===
+/home/josh/Dev/rescript-vike/node_modules/rescript/linux/rescript.exe	0x1.94982aab26773p+30
diff --git a/node_modules/rescript-relay/lib/bs/.compiler.log b/node_modules/rescript-relay/lib/bs/.compiler.log
new file mode 100644
index 0000000..42db298
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/.compiler.log
@@ -0,0 +1,2 @@
+#Start(1696992481871)
+#Done(1696992481872)
diff --git a/node_modules/rescript-relay/lib/bs/.ninja_log b/node_modules/rescript-relay/lib/bs/.ninja_log
new file mode 100644
index 0000000..8d62104
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/.ninja_log
@@ -0,0 +1,60 @@
+# ninja log v6
+0	14	1696992028547564000	src/RescriptRelay_Subscriptions.iast	28d6d06dbd87dea0
+0	15	1696992028547564000	src/RescriptRelay_RelayResolvers.ast	3265aaf9b0ca28ce
+1	15	1696992028547564000	src/RescriptRelay_Subscriptions.ast	27a0300b6cf7c259
+3	17	1696992028547564000	src/RescriptRelayUtils.iast	688e8f1963dde7b1
+4	17	1696992028547564000	src/ReactDOMExperimental.ast	5f0e9e92cf41c8b
+1	18	1696992028547564000	src/RescriptRelay_RelayResolvers.iast	6e7fdcbf945c3dfb
+1	19	1696992028547564000	src/RescriptRelay_Mutation.ast	5efc1885fabe6142
+2	19	1696992028547564000	src/RescriptRelay_Internal.ast	f756d7946b0a6b70
+2	19	1696992028547564000	src/RescriptRelay_Internal.iast	ba90b93e75dbfe38
+3	19	1696992028547564000	src/RescriptRelay_Fragment.iast	342121415421e82a
+4	19	1696992028547564000	src/RescriptRelay_Query.iast	bc36f09cbea82361
+16	19	1696992028547564000	src/RescriptRelay_Subscriptions.d	f3470b13f8289468
+1	20	1696992028547564000	src/RescriptRelay_Mutation.iast	988a61ac93aa9a3a
+2	20	1696992028557564000	src/RescriptRelay_Fragment.ast	5f747d4d3096eb97
+3	20	1696992028547564000	src/RescriptRelay_Query.ast	cb4fea5f605a9cc3
+17	20	1696992028557564000	src/ReactDOMExperimental.d	ce63ffa0cacc675f
+18	21	1696992028557564000	src/RescriptRelay_RelayResolvers.d	ece78a9f6aac0984
+7	21	1696992028557564000	src/ReactExperimental.iast	af6b871631bf1175
+19	21	1696992028557564000	src/RescriptRelay_Internal.d	84af44e864c26bbc
+20	22	1696992028557564000	src/RescriptRelay_Mutation.d	9876d396fd7375af
+20	22	1696992028557564000	src/RescriptRelay_Fragment.d	735668ac3178f6c6
+20	22	1696992028557564000	src/RescriptRelay_Query.d	dde3306ddca82d11
+9	26	1696992028557564000	src/ReactExperimental.ast	11799c19ed60498a
+14	27	1696992028557564000	src/RescriptRelayUtils.ast	b76d5ed4ac7d64d9
+26	29	1696992028567564000	src/ReactExperimental.d	e65dd0fb350659a2
+27	30	1696992028567564000	src/RescriptRelayUtils.d	7209eafb4372cbca
+10	31	1696992028567564000	src/RescriptRelay.ast	71f35a3dd52126c5
+21	35	1696992028567564000	src/RescriptRelay_Internal.cmi	35af70ef8a3442c4
+8	36	1696992028567564000	src/RescriptRelay.iast	3fc2f4266fdcaedf
+36	37	1696992028567564000	src/RescriptRelay.d	52e1e36ed4327e37
+21	39	1696992028567564000	src/ReactDOMExperimental.cmj	a2e6138827076310
+21	39	1696992028567564000	src/ReactDOMExperimental.cmi	a2e6138827076310
+21	39	1696992028567564000	../../src/ReactDOMExperimental.mjs	a2e6138827076310
+29	40	1696992028577564000	src/ReactExperimental.cmi	b59b9c1efb029c14
+35	50	1696992028587564000	src/RescriptRelay_Internal.cmj	4a93bfecbfaba20a
+35	50	1696992028587564000	../../src/RescriptRelay_Internal.mjs	4a93bfecbfaba20a
+41	52	1696992028587564000	src/ReactExperimental.cmj	eb6f75eea5b43090
+41	52	1696992028587564000	../../src/ReactExperimental.mjs	eb6f75eea5b43090
+38	60	1696992028587564000	src/RescriptRelay.cmi	860b473c252cfe40
+61	71	1696992028607564000	src/RescriptRelayUtils.cmi	adf42102414d87ee
+60	71	1696992028607564000	src/RescriptRelay_Subscriptions.cmi	e094ff77051fcbc
+60	72	1696992028607564000	src/RescriptRelay_Mutation.cmi	f2d2ac5760ceb09f
+61	73	1696992028607564000	src/RescriptRelay_Query.cmi	6dc393f8fbcc5429
+60	74	1696992028607564000	src/RescriptRelay_RelayResolvers.cmi	708a94e85a29d9e2
+61	76	1696992028607564000	src/RescriptRelay_Fragment.cmi	ba3a7d7c1d554948
+61	93	1696992028627564000	src/RescriptRelay.cmj	cd8c524773197307
+61	93	1696992028627564000	../../src/RescriptRelay.mjs	cd8c524773197307
+93	105	1696992028637564000	src/RescriptRelay_RelayResolvers.cmj	fc5d33c939f4ac04
+93	105	1696992028637564000	../../src/RescriptRelay_RelayResolvers.mjs	fc5d33c939f4ac04
+93	106	1696992028637564000	src/RescriptRelay_Subscriptions.cmj	78e9d5c7ac910c1e
+93	106	1696992028637564000	../../src/RescriptRelay_Subscriptions.mjs	78e9d5c7ac910c1e
+93	110	1696992028647564000	src/RescriptRelay_Mutation.cmj	88c6dedb07208d65
+93	110	1696992028647564000	../../src/RescriptRelay_Mutation.mjs	88c6dedb07208d65
+94	110	1696992028647564000	src/RescriptRelayUtils.cmj	4f4d9f2351d2035d
+94	110	1696992028647564000	../../src/RescriptRelayUtils.mjs	4f4d9f2351d2035d
+94	111	1696992028647564000	src/RescriptRelay_Fragment.cmj	d8a5f2ddcedfc447
+94	111	1696992028647564000	../../src/RescriptRelay_Fragment.mjs	d8a5f2ddcedfc447
+94	112	1696992028647564000	src/RescriptRelay_Query.cmj	d8791c13b86a979
+94	112	1696992028647564000	../../src/RescriptRelay_Query.mjs	d8791c13b86a979
diff --git a/node_modules/rescript-relay/lib/bs/build.ninja b/node_modules/rescript-relay/lib/bs/build.ninja
new file mode 100644
index 0000000..cab498b
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/build.ninja
@@ -0,0 +1,67 @@
+rescript = 1
+g_finger := /home/josh/Dev/rescript-vike/node_modules/@rescript/react/lib/ocaml/install.stamp
+rule astj
+  command = /home/josh/Dev/rescript-vike/node_modules/rescript/linux/bsc.exe  -w a -bs-v 11.0.0-rc.4 -bs-jsx 4 -bs-jsx-mode automatic  -absname -bs-ast -o $out $i
+o src/RescriptRelay.ast : astj ../../src/RescriptRelay.res
+rule deps
+  command = /home/josh/Dev/rescript-vike/node_modules/rescript/linux/bsb_helper.exe -hash 7ecd8d4624da40dd9115b8a5947ed1e5 $in
+  restat = 1
+o src/RescriptRelay.d : deps src/RescriptRelay.ast src/RescriptRelay.iast
+o src/RescriptRelay.iast : astj ../../src/RescriptRelay.resi
+rule mi
+  command = /home/josh/Dev/rescript-vike/node_modules/rescript/linux/bsc.exe -I src -I /home/josh/Dev/rescript-vike/node_modules/@rescript/react/lib/ocaml   -w a -bs-v $g_finger $i
+  dyndep = 1
+  restat = 1
+o src/RescriptRelay.cmi : mi src/RescriptRelay.iast
+rule mj
+  command = /home/josh/Dev/rescript-vike/node_modules/rescript/linux/bsc.exe -bs-read-cmi -I src -I /home/josh/Dev/rescript-vike/node_modules/@rescript/react/lib/ocaml   -w a -bs-package-name rescript-relay -bs-package-output es6:$in_d:.mjs -bs-v $g_finger $i
+  dyndep = 1
+  restat = 1
+o src/RescriptRelay.cmj ../../src/RescriptRelay.mjs : mj src/RescriptRelay.ast src/RescriptRelay.cmi
+o src/ReactExperimental.ast : astj ../../src/ReactExperimental.res
+o src/ReactExperimental.d : deps src/ReactExperimental.ast src/ReactExperimental.iast
+o src/ReactExperimental.iast : astj ../../src/ReactExperimental.resi
+o src/ReactExperimental.cmi : mi src/ReactExperimental.iast
+o src/ReactExperimental.cmj ../../src/ReactExperimental.mjs : mj src/ReactExperimental.ast src/ReactExperimental.cmi
+o src/RescriptRelayUtils.ast : astj ../../src/RescriptRelayUtils.res
+o src/RescriptRelayUtils.d : deps src/RescriptRelayUtils.ast src/RescriptRelayUtils.iast
+o src/RescriptRelayUtils.iast : astj ../../src/RescriptRelayUtils.resi
+o src/RescriptRelayUtils.cmi : mi src/RescriptRelayUtils.iast
+o src/RescriptRelayUtils.cmj ../../src/RescriptRelayUtils.mjs : mj src/RescriptRelayUtils.ast src/RescriptRelayUtils.cmi
+o src/RescriptRelay_Query.ast : astj ../../src/RescriptRelay_Query.res
+o src/RescriptRelay_Query.d : deps src/RescriptRelay_Query.ast src/RescriptRelay_Query.iast
+o src/RescriptRelay_Query.iast : astj ../../src/RescriptRelay_Query.resi
+o src/RescriptRelay_Query.cmi : mi src/RescriptRelay_Query.iast
+o src/RescriptRelay_Query.cmj ../../src/RescriptRelay_Query.mjs : mj src/RescriptRelay_Query.ast src/RescriptRelay_Query.cmi
+o src/ReactDOMExperimental.ast : astj ../../src/ReactDOMExperimental.res
+o src/ReactDOMExperimental.d : deps src/ReactDOMExperimental.ast
+rule mij
+  command = /home/josh/Dev/rescript-vike/node_modules/rescript/linux/bsc.exe -I src -I /home/josh/Dev/rescript-vike/node_modules/@rescript/react/lib/ocaml   -w a -bs-package-name rescript-relay -bs-package-output es6:$in_d:.mjs -bs-v $g_finger $i
+  dyndep = 1
+  restat = 1
+o src/ReactDOMExperimental.cmj src/ReactDOMExperimental.cmi ../../src/ReactDOMExperimental.mjs : mij src/ReactDOMExperimental.ast
+o src/RescriptRelay_Fragment.ast : astj ../../src/RescriptRelay_Fragment.res
+o src/RescriptRelay_Fragment.d : deps src/RescriptRelay_Fragment.ast src/RescriptRelay_Fragment.iast
+o src/RescriptRelay_Fragment.iast : astj ../../src/RescriptRelay_Fragment.resi
+o src/RescriptRelay_Fragment.cmi : mi src/RescriptRelay_Fragment.iast
+o src/RescriptRelay_Fragment.cmj ../../src/RescriptRelay_Fragment.mjs : mj src/RescriptRelay_Fragment.ast src/RescriptRelay_Fragment.cmi
+o src/RescriptRelay_Internal.ast : astj ../../src/RescriptRelay_Internal.res
+o src/RescriptRelay_Internal.d : deps src/RescriptRelay_Internal.ast src/RescriptRelay_Internal.iast
+o src/RescriptRelay_Internal.iast : astj ../../src/RescriptRelay_Internal.resi
+o src/RescriptRelay_Internal.cmi : mi src/RescriptRelay_Internal.iast
+o src/RescriptRelay_Internal.cmj ../../src/RescriptRelay_Internal.mjs : mj src/RescriptRelay_Internal.ast src/RescriptRelay_Internal.cmi
+o src/RescriptRelay_Mutation.ast : astj ../../src/RescriptRelay_Mutation.res
+o src/RescriptRelay_Mutation.d : deps src/RescriptRelay_Mutation.ast src/RescriptRelay_Mutation.iast
+o src/RescriptRelay_Mutation.iast : astj ../../src/RescriptRelay_Mutation.resi
+o src/RescriptRelay_Mutation.cmi : mi src/RescriptRelay_Mutation.iast
+o src/RescriptRelay_Mutation.cmj ../../src/RescriptRelay_Mutation.mjs : mj src/RescriptRelay_Mutation.ast src/RescriptRelay_Mutation.cmi
+o src/RescriptRelay_Subscriptions.ast : astj ../../src/RescriptRelay_Subscriptions.res
+o src/RescriptRelay_Subscriptions.d : deps src/RescriptRelay_Subscriptions.ast src/RescriptRelay_Subscriptions.iast
+o src/RescriptRelay_Subscriptions.iast : astj ../../src/RescriptRelay_Subscriptions.resi
+o src/RescriptRelay_Subscriptions.cmi : mi src/RescriptRelay_Subscriptions.iast
+o src/RescriptRelay_Subscriptions.cmj ../../src/RescriptRelay_Subscriptions.mjs : mj src/RescriptRelay_Subscriptions.ast src/RescriptRelay_Subscriptions.cmi
+o src/RescriptRelay_RelayResolvers.ast : astj ../../src/RescriptRelay_RelayResolvers.res
+o src/RescriptRelay_RelayResolvers.d : deps src/RescriptRelay_RelayResolvers.ast src/RescriptRelay_RelayResolvers.iast
+o src/RescriptRelay_RelayResolvers.iast : astj ../../src/RescriptRelay_RelayResolvers.resi
+o src/RescriptRelay_RelayResolvers.cmi : mi src/RescriptRelay_RelayResolvers.iast
+o src/RescriptRelay_RelayResolvers.cmj ../../src/RescriptRelay_RelayResolvers.mjs : mj src/RescriptRelay_RelayResolvers.ast src/RescriptRelay_RelayResolvers.cmi
diff --git a/node_modules/rescript-relay/lib/bs/install.ninja b/node_modules/rescript-relay/lib/bs/install.ninja
new file mode 100644
index 0000000..41cb752
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/install.ninja
@@ -0,0 +1,64 @@
+rescript = 1
+rule cp
+  command = cp $i $out
+rule touch
+ command = touch $out
+o RescriptRelay.cmi : cp ../bs/src/RescriptRelay.cmi
+o RescriptRelay.cmj : cp ../bs/src/RescriptRelay.cmj
+o RescriptRelay.cmt : cp ../bs/src/RescriptRelay.cmt
+o RescriptRelay.res : cp ../../src/RescriptRelay.res
+o RescriptRelay.resi : cp ../../src/RescriptRelay.resi
+o RescriptRelay.cmti : cp ../bs/src/RescriptRelay.cmti
+o ReactExperimental.cmi : cp ../bs/src/ReactExperimental.cmi
+o ReactExperimental.cmj : cp ../bs/src/ReactExperimental.cmj
+o ReactExperimental.cmt : cp ../bs/src/ReactExperimental.cmt
+o ReactExperimental.res : cp ../../src/ReactExperimental.res
+o ReactExperimental.resi : cp ../../src/ReactExperimental.resi
+o ReactExperimental.cmti : cp ../bs/src/ReactExperimental.cmti
+o RescriptRelayUtils.cmi : cp ../bs/src/RescriptRelayUtils.cmi
+o RescriptRelayUtils.cmj : cp ../bs/src/RescriptRelayUtils.cmj
+o RescriptRelayUtils.cmt : cp ../bs/src/RescriptRelayUtils.cmt
+o RescriptRelayUtils.res : cp ../../src/RescriptRelayUtils.res
+o RescriptRelayUtils.resi : cp ../../src/RescriptRelayUtils.resi
+o RescriptRelayUtils.cmti : cp ../bs/src/RescriptRelayUtils.cmti
+o RescriptRelay_Query.cmi : cp ../bs/src/RescriptRelay_Query.cmi
+o RescriptRelay_Query.cmj : cp ../bs/src/RescriptRelay_Query.cmj
+o RescriptRelay_Query.cmt : cp ../bs/src/RescriptRelay_Query.cmt
+o RescriptRelay_Query.res : cp ../../src/RescriptRelay_Query.res
+o RescriptRelay_Query.resi : cp ../../src/RescriptRelay_Query.resi
+o RescriptRelay_Query.cmti : cp ../bs/src/RescriptRelay_Query.cmti
+o ReactDOMExperimental.cmi : cp ../bs/src/ReactDOMExperimental.cmi
+o ReactDOMExperimental.cmj : cp ../bs/src/ReactDOMExperimental.cmj
+o ReactDOMExperimental.cmt : cp ../bs/src/ReactDOMExperimental.cmt
+o ReactDOMExperimental.res : cp ../../src/ReactDOMExperimental.res
+o RescriptRelay_Fragment.cmi : cp ../bs/src/RescriptRelay_Fragment.cmi
+o RescriptRelay_Fragment.cmj : cp ../bs/src/RescriptRelay_Fragment.cmj
+o RescriptRelay_Fragment.cmt : cp ../bs/src/RescriptRelay_Fragment.cmt
+o RescriptRelay_Fragment.res : cp ../../src/RescriptRelay_Fragment.res
+o RescriptRelay_Fragment.resi : cp ../../src/RescriptRelay_Fragment.resi
+o RescriptRelay_Fragment.cmti : cp ../bs/src/RescriptRelay_Fragment.cmti
+o RescriptRelay_Internal.cmi : cp ../bs/src/RescriptRelay_Internal.cmi
+o RescriptRelay_Internal.cmj : cp ../bs/src/RescriptRelay_Internal.cmj
+o RescriptRelay_Internal.cmt : cp ../bs/src/RescriptRelay_Internal.cmt
+o RescriptRelay_Internal.res : cp ../../src/RescriptRelay_Internal.res
+o RescriptRelay_Internal.resi : cp ../../src/RescriptRelay_Internal.resi
+o RescriptRelay_Internal.cmti : cp ../bs/src/RescriptRelay_Internal.cmti
+o RescriptRelay_Mutation.cmi : cp ../bs/src/RescriptRelay_Mutation.cmi
+o RescriptRelay_Mutation.cmj : cp ../bs/src/RescriptRelay_Mutation.cmj
+o RescriptRelay_Mutation.cmt : cp ../bs/src/RescriptRelay_Mutation.cmt
+o RescriptRelay_Mutation.res : cp ../../src/RescriptRelay_Mutation.res
+o RescriptRelay_Mutation.resi : cp ../../src/RescriptRelay_Mutation.resi
+o RescriptRelay_Mutation.cmti : cp ../bs/src/RescriptRelay_Mutation.cmti
+o RescriptRelay_Subscriptions.cmi : cp ../bs/src/RescriptRelay_Subscriptions.cmi
+o RescriptRelay_Subscriptions.cmj : cp ../bs/src/RescriptRelay_Subscriptions.cmj
+o RescriptRelay_Subscriptions.cmt : cp ../bs/src/RescriptRelay_Subscriptions.cmt
+o RescriptRelay_Subscriptions.res : cp ../../src/RescriptRelay_Subscriptions.res
+o RescriptRelay_Subscriptions.resi : cp ../../src/RescriptRelay_Subscriptions.resi
+o RescriptRelay_Subscriptions.cmti : cp ../bs/src/RescriptRelay_Subscriptions.cmti
+o RescriptRelay_RelayResolvers.cmi : cp ../bs/src/RescriptRelay_RelayResolvers.cmi
+o RescriptRelay_RelayResolvers.cmj : cp ../bs/src/RescriptRelay_RelayResolvers.cmj
+o RescriptRelay_RelayResolvers.cmt : cp ../bs/src/RescriptRelay_RelayResolvers.cmt
+o RescriptRelay_RelayResolvers.res : cp ../../src/RescriptRelay_RelayResolvers.res
+o RescriptRelay_RelayResolvers.resi : cp ../../src/RescriptRelay_RelayResolvers.resi
+o RescriptRelay_RelayResolvers.cmti : cp ../bs/src/RescriptRelay_RelayResolvers.cmti
+build install.stamp : touch RescriptRelay.cmi RescriptRelay.cmj ReactExperimental.cmi ReactExperimental.cmj RescriptRelayUtils.cmi RescriptRelayUtils.cmj RescriptRelay_Query.cmi RescriptRelay_Query.cmj ReactDOMExperimental.cmi ReactDOMExperimental.cmj RescriptRelay_Fragment.cmi RescriptRelay_Fragment.cmj RescriptRelay_Internal.cmi RescriptRelay_Internal.cmj RescriptRelay_Mutation.cmi RescriptRelay_Mutation.cmj RescriptRelay_Subscriptions.cmi RescriptRelay_Subscriptions.cmj RescriptRelay_RelayResolvers.cmi RescriptRelay_RelayResolvers.cmj 
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.ast b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.ast
new file mode 100644
index 0000000..85eaf77
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmi b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmi
new file mode 100644
index 0000000..105e782
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmj b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmj
new file mode 100644
index 0000000..8c07884
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmt b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmt
new file mode 100644
index 0000000..be01e47
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.d b/node_modules/rescript-relay/lib/bs/src/ReactDOMExperimental.d
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactExperimental.ast b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.ast
new file mode 100644
index 0000000..f672041
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmi b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmi
new file mode 100644
index 0000000..e967667
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmj b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmj
new file mode 100644
index 0000000..bd30bd1
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmt b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmt
new file mode 100644
index 0000000..987d33b
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmti b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmti
new file mode 100644
index 0000000..5c1b599
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactExperimental.d b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.d
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/rescript-relay/lib/bs/src/ReactExperimental.iast b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.iast
new file mode 100644
index 0000000..9cabe9f
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/ReactExperimental.iast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay.ast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.ast
new file mode 100644
index 0000000..c021e1f
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmi b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmi
new file mode 100644
index 0000000..b9d69ec
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmj b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmj
new file mode 100644
index 0000000..eb7db89
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmt b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmt
new file mode 100644
index 0000000..a49a4d1
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmti b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmti
new file mode 100644
index 0000000..13d914e
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay.d b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.d
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay.iast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.iast
new file mode 100644
index 0000000..aadc490
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay.iast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.ast b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.ast
new file mode 100644
index 0000000..0fd9c19
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmi b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmi
new file mode 100644
index 0000000..d8d7548
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmj b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmj
new file mode 100644
index 0000000..2f96ba4
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmt b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmt
new file mode 100644
index 0000000..fa85238
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmti b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmti
new file mode 100644
index 0000000..3735892
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.d b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.d
new file mode 100644
index 0000000..02b8702
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.d
@@ -0,0 +1,2 @@
+src/RescriptRelayUtils.cmj : src/RescriptRelay.cmj src/RescriptRelay.cmi
+src/RescriptRelayUtils.cmi :  src/RescriptRelay.cmi
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.iast b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.iast
new file mode 100644
index 0000000..5dcfc1e
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelayUtils.iast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.ast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.ast
new file mode 100644
index 0000000..61359a7
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmi b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmi
new file mode 100644
index 0000000..298f228
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmj b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmj
new file mode 100644
index 0000000..05f1b6b
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmt b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmt
new file mode 100644
index 0000000..47dbf9f
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmti b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmti
new file mode 100644
index 0000000..919376f
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.d b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.d
new file mode 100644
index 0000000..2c1dbc2
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.d
@@ -0,0 +1,2 @@
+src/RescriptRelay_Fragment.cmj : src/RescriptRelay.cmj src/RescriptRelay.cmi src/RescriptRelay_Internal.cmj src/RescriptRelay_Internal.cmi
+src/RescriptRelay_Fragment.cmi :  src/RescriptRelay.cmi
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.iast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.iast
new file mode 100644
index 0000000..fafcc8a
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Fragment.iast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.ast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.ast
new file mode 100644
index 0000000..c4a8f0c
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmi b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmi
new file mode 100644
index 0000000..bada84b
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmj b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmj
new file mode 100644
index 0000000..0082c1f
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmt b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmt
new file mode 100644
index 0000000..571805e
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmti b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmti
new file mode 100644
index 0000000..91347d6
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.d b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.d
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.iast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.iast
new file mode 100644
index 0000000..cfdd5ed
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Internal.iast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.ast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.ast
new file mode 100644
index 0000000..9d945e5
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmi b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmi
new file mode 100644
index 0000000..8161755
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmj b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmj
new file mode 100644
index 0000000..63c016d
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmt b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmt
new file mode 100644
index 0000000..4d4e546
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmti b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmti
new file mode 100644
index 0000000..ee6caeb
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.d b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.d
new file mode 100644
index 0000000..b3c28ce
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.d
@@ -0,0 +1,2 @@
+src/RescriptRelay_Mutation.cmj : src/RescriptRelay.cmj src/RescriptRelay.cmi
+src/RescriptRelay_Mutation.cmi :  src/RescriptRelay.cmi
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.iast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.iast
new file mode 100644
index 0000000..5fda0a0
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Mutation.iast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.ast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.ast
new file mode 100644
index 0000000..0bd2867
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmi b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmi
new file mode 100644
index 0000000..a7480e9
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmj b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmj
new file mode 100644
index 0000000..0f71dab
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmt b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmt
new file mode 100644
index 0000000..817ea75
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmti b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmti
new file mode 100644
index 0000000..5a013c6
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.d b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.d
new file mode 100644
index 0000000..83f20bb
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.d
@@ -0,0 +1,2 @@
+src/RescriptRelay_Query.cmj : src/RescriptRelay.cmj src/RescriptRelay.cmi src/RescriptRelay_Internal.cmj src/RescriptRelay_Internal.cmi
+src/RescriptRelay_Query.cmi :  src/RescriptRelay.cmi
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.iast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.iast
new file mode 100644
index 0000000..cf732f2
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Query.iast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.ast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.ast
new file mode 100644
index 0000000..d06f32a
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmi b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmi
new file mode 100644
index 0000000..4d26d53
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmj b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmj
new file mode 100644
index 0000000..9c909af
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmt b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmt
new file mode 100644
index 0000000..f1ef608
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmti b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmti
new file mode 100644
index 0000000..995f898
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.d b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.d
new file mode 100644
index 0000000..fc3dfb5
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.d
@@ -0,0 +1,2 @@
+src/RescriptRelay_RelayResolvers.cmj : src/RescriptRelay.cmj src/RescriptRelay.cmi
+src/RescriptRelay_RelayResolvers.cmi :  src/RescriptRelay.cmi
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.iast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.iast
new file mode 100644
index 0000000..66d8213
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_RelayResolvers.iast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.ast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.ast
new file mode 100644
index 0000000..6d660e8
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.ast differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmi b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmi
new file mode 100644
index 0000000..20f504b
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmi differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmj b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmj
new file mode 100644
index 0000000..b143651
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmj differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmt b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmt
new file mode 100644
index 0000000..f8c2fc6
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmt differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmti b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmti
new file mode 100644
index 0000000..18680b1
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.cmti differ
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.d b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.d
new file mode 100644
index 0000000..a1b380f
--- /dev/null
+++ b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.d
@@ -0,0 +1,2 @@
+src/RescriptRelay_Subscriptions.cmj : src/RescriptRelay.cmj src/RescriptRelay.cmi
+src/RescriptRelay_Subscriptions.cmi :  src/RescriptRelay.cmi
diff --git a/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.iast b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.iast
new file mode 100644
index 0000000..8ed2e3a
Binary files /dev/null and b/node_modules/rescript-relay/lib/bs/src/RescriptRelay_Subscriptions.iast differ
diff --git a/node_modules/rescript-relay/lib/ocaml/.compiler.log b/node_modules/rescript-relay/lib/ocaml/.compiler.log
new file mode 100644
index 0000000..4fff6fa
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/.compiler.log
@@ -0,0 +1,2 @@
+#Start(1696992481873)
+#Done(1696992481873)
diff --git a/node_modules/rescript-relay/lib/ocaml/.ninja_log b/node_modules/rescript-relay/lib/ocaml/.ninja_log
new file mode 100644
index 0000000..0c42dd5
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/.ninja_log
@@ -0,0 +1,60 @@
+# ninja log v6
+0	5	1696992028647564000	RescriptRelay_RelayResolvers.resi	6dcd5ea131dfcf43
+0	5	1696992028647564000	RescriptRelay_RelayResolvers.cmti	a574946f579b854f
+1	6	1696992028647564000	RescriptRelay_Mutation.cmi	97303af76b882710
+1	6	1696992028647564000	RescriptRelay_Mutation.cmj	35360a2c71da10de
+1	6	1696992028647564000	RescriptRelay_Mutation.cmt	e45bee93a12b841c
+1	6	1696992028647564000	RescriptRelay_Mutation.res	cceec4b46212116b
+2	7	1696992028647564000	RescriptRelay_Mutation.resi	f055ec977fe9f9e3
+2	7	1696992028647564000	RescriptRelay_Mutation.cmti	ef3ffd18ed715dfc
+2	7	1696992028647564000	RescriptRelay_Subscriptions.cmi	434d8a2e3bc74bd2
+3	8	1696992028647564000	RescriptRelay_Subscriptions.cmj	42cdd8f9fb42cfe9
+3	8	1696992028647564000	RescriptRelay_Subscriptions.cmt	e94d7455c7393bde
+3	9	1696992028657564000	RescriptRelay_Subscriptions.res	4860f1a23f4534e3
+3	9	1696992028657564000	RescriptRelay_Subscriptions.resi	e77bf940f05115aa
+4	9	1696992028657564000	RescriptRelay_Subscriptions.cmti	798b71ad04770b98
+4	10	1696992028657564000	RescriptRelay_RelayResolvers.cmi	4c7ed53bd5351146
+4	10	1696992028657564000	RescriptRelay_RelayResolvers.cmj	a99312b3785ffb08
+4	10	1696992028657564000	RescriptRelay_RelayResolvers.cmt	4fd4ef7e20b6a8a7
+5	11	1696992028657564000	RescriptRelay_RelayResolvers.res	9c8453f750635c76
+5	11	1696992028657564000	RescriptRelay_Fragment.cmi	88da6c7b7c782d53
+5	11	1696992028657564000	RescriptRelay_Fragment.cmj	a037630c03273f65
+6	12	1696992028657564000	RescriptRelay_Fragment.cmt	2f2bffbe3847db9b
+6	12	1696992028657564000	RescriptRelay_Fragment.res	126df1af946efa42
+6	13	1696992028657564000	RescriptRelay_Fragment.resi	db8a9609d3ccccb4
+7	13	1696992028657564000	RescriptRelay_Fragment.cmti	6980096f28380a1a
+7	13	1696992028657564000	RescriptRelay_Internal.cmi	dc0a2ffdaf85e202
+7	14	1696992028657564000	RescriptRelay_Internal.cmj	a426bee790797859
+7	14	1696992028657564000	RescriptRelay_Internal.cmt	836561610d181f7f
+8	14	1696992028657564000	RescriptRelay_Internal.res	23ee938fdfdc31d
+8	15	1696992028657564000	RescriptRelay_Internal.resi	e931516c6b3e3ae0
+9	15	1696992028657564000	RescriptRelay_Internal.cmti	5c49ee3fa30d842c
+9	15	1696992028657564000	ReactDOMExperimental.cmi	1fef3dc8206724db
+9	16	1696992028657564000	ReactDOMExperimental.cmj	cdf077e11405dc87
+10	16	1696992028657564000	ReactDOMExperimental.cmt	c4471f9cdb6f926e
+10	16	1696992028657564000	ReactDOMExperimental.res	2cec70162b5cb96b
+10	17	1696992028657564000	RescriptRelayUtils.resi	f0de1d7aede6c42d
+11	17	1696992028657564000	RescriptRelayUtils.cmti	1e7807b7fe468d76
+11	18	1696992028657564000	RescriptRelay_Query.cmi	45be063d0a145e64
+12	18	1696992028657564000	RescriptRelay_Query.cmj	58d1c3bcf455790b
+12	18	1696992028657564000	ReactExperimental.cmt	cf5262e8730398db
+12	19	1696992028657564000	ReactExperimental.res	e9127ffc3071f6dd
+13	19	1696992028657564000	ReactExperimental.resi	fd8f6331467072c1
+13	19	1696992028657564000	ReactExperimental.cmti	74b0c9692be6ccec
+13	19	1696992028667564000	RescriptRelay_Query.cmt	4892405a57fdd213
+14	19	1696992028667564000	RescriptRelay_Query.res	e55e3d12cc88d441
+14	19	1696992028667564000	RescriptRelay_Query.resi	e861da02950a681c
+14	19	1696992028667564000	RescriptRelay_Query.cmti	17df1381297b3d03
+15	19	1696992028667564000	RescriptRelayUtils.cmi	75f63509ba200e2a
+15	19	1696992028667564000	RescriptRelayUtils.cmj	95da8eeddac77e19
+15	20	1696992028667564000	RescriptRelayUtils.cmt	8a8608735ecbb474
+16	20	1696992028667564000	RescriptRelayUtils.res	bb67bf674721a775
+16	20	1696992028667564000	RescriptRelay.res	ee447a130e505c53
+16	20	1696992028667564000	RescriptRelay.resi	676ce9fa0d9e105
+17	20	1696992028667564000	RescriptRelay.cmti	3b4f11e0594fef7a
+17	20	1696992028667564000	ReactExperimental.cmi	d171b5c2b25900e9
+18	20	1696992028667564000	RescriptRelay.cmi	63815ce19446c6e7
+18	20	1696992028667564000	ReactExperimental.cmj	fcad90c6038475b9
+18	20	1696992028667564000	RescriptRelay.cmj	c0eee54aa9ea0db3
+19	21	1696992028667564000	RescriptRelay.cmt	2bde18bbe1a27518
+21	22	1696992028667564000	install.stamp	cff5a5b4c02d30cf
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmi b/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmi
new file mode 100644
index 0000000..105e782
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmj b/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmj
new file mode 100644
index 0000000..8c07884
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmt b/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmt
new file mode 100644
index 0000000..be01e47
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.res b/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.res
new file mode 100644
index 0000000..07b62e1
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/ReactDOMExperimental.res
@@ -0,0 +1,16 @@
+include ReactDOM.Client
+
+@val @return(nullable)
+external getElementById: string => option<Dom.element> = "document.getElementById"
+
+let renderConcurrentRootAtElementWithId: (React.element, string) => unit = (content, id) =>
+  switch getElementById(id) {
+  | None =>
+    raise(
+      Invalid_argument(
+        "ReactExperimental.renderConcurrentRootAtElementWithId : no element of id " ++
+        id ++ " found in the HTML.",
+      ),
+    )
+  | Some(element) => createRoot(element)->Root.render(content)
+  }
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmi b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmi
new file mode 100644
index 0000000..e967667
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmj b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmj
new file mode 100644
index 0000000..bd30bd1
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmt b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmt
new file mode 100644
index 0000000..987d33b
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmti b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmti
new file mode 100644
index 0000000..5c1b599
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactExperimental.res b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.res
new file mode 100644
index 0000000..f7f3ed6
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.res
@@ -0,0 +1,21 @@
+@module("react")
+external useDeferredValue: 'value => 'value = "useDeferredValue"
+
+@module("react")
+external useTransitionWithOptions: unit => (
+  bool,
+  (. unit => unit, option<{"name": option<string>}>) => unit,
+) = "useTransition"
+
+let useTransition = () => {
+  let (isPending, startTransition) = useTransitionWithOptions()
+  (isPending, React.useMemo1(() => cb => startTransition(. cb, None), [startTransition]))
+}
+
+module SuspenseList = {
+  @module("react") @react.component
+  external make: (
+    ~children: React.element,
+    ~revealOrder: [#forwards | #backwards | #together]=?,
+  ) => React.element = "SuspenseList"
+}
diff --git a/node_modules/rescript-relay/lib/ocaml/ReactExperimental.resi b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.resi
new file mode 100644
index 0000000..2e5a541
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/ReactExperimental.resi
@@ -0,0 +1,18 @@
+@module("react")
+external useDeferredValue: 'value => 'value = "useDeferredValue"
+
+@module("react")
+external useTransitionWithOptions: unit => (
+  bool,
+  (. unit => unit, option<{"name": option<string>}>) => unit,
+) = "useTransition"
+
+let useTransition: unit => (bool, (unit => unit) => unit)
+
+module SuspenseList: {
+  @module("react") @react.component
+  external make: (
+    ~children: React.element,
+    ~revealOrder: [#forwards | #backwards | #together]=?,
+  ) => React.element = "SuspenseList"
+}
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmi
new file mode 100644
index 0000000..b9d69ec
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmj b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmj
new file mode 100644
index 0000000..eb7db89
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmt b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmt
new file mode 100644
index 0000000..a49a4d1
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmti b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmti
new file mode 100644
index 0000000..13d914e
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay.res b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.res
new file mode 100644
index 0000000..813340f
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.res
@@ -0,0 +1,776 @@
+type arguments
+type allFieldsMasked = {.}
+
+type any
+
+type queryNode<'node>
+type fragmentNode<'node>
+type mutationNode<'node>
+type subscriptionNode<'node>
+
+type fragmentRefs<'fragments>
+
+type dataId
+type recordSourceRecords = Js.Json.t
+type uploadables
+
+external dataIdToString: dataId => string = "%identity"
+external makeDataId: string => dataId = "%identity"
+external makeArguments: {..} => arguments = "%identity"
+external makeUploadables: Js.Dict.t<'file> => uploadables = "%identity"
+external unwrapUploadables: uploadables => Js.Dict.t<'file> = "%identity"
+
+@module("relay-runtime")
+external generateClientID: (~dataId: dataId, ~storageKey: string, ~index: int=?, unit) => dataId =
+  "generateClientID"
+
+@module("relay-runtime")
+external generateUniqueClientID: unit => dataId = "generateUniqueClientID"
+
+@module("relay-runtime")
+external isClientID: dataId => bool = "isClientID"
+
+type featureFlags = {
+  @as("DELAY_CLEANUP_OF_PENDING_PRELOAD_QUERIES")
+  mutable delayCleanupOfPendingPreloadQueries: bool,
+  @as("ENABLE_CLIENT_EDGES")
+  mutable enableClientEdges: bool,
+  @as("ENABLE_VARIABLE_CONNECTION_KEY")
+  mutable enableVariableConnectionKey: bool,
+  @as("ENABLE_PARTIAL_RENDERING_DEFAULT")
+  mutable enablePartialRenderingDefault: bool,
+  @as("ENABLE_REACT_FLIGHT_COMPONENT_FIELD")
+  mutable enableReactFlightComponentField: bool,
+  @as("ENABLE_RELAY_RESOLVERS")
+  mutable enableRelayResolvers: bool,
+  @as("ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION")
+  mutable enableGetFragmentIdentifierOptimization: bool,
+  @as("ENABLE_FRIENDLY_QUERY_NAME_GQL_URL")
+  mutable enableFriendlyQueryNameGqlUrl: bool,
+  @as("ENABLE_LOAD_QUERY_REQUEST_DEDUPING")
+  mutable enableLoadQueryRequestDeduping: bool,
+  @as("ENABLE_DO_NOT_WRAP_LIVE_QUERY")
+  mutable enableDoNotWrapLiveQuery: bool,
+  @as("ENABLE_NOTIFY_SUBSCRIPTION")
+  mutable enableNotifySubscription: bool,
+  @as("ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT")
+  mutable enableContainersSubscribeOnCommit: bool,
+  @as("ENABLE_QUERY_RENDERER_OFFSCREEN_SUPPORT")
+  mutable enableQueryRendererOffscreenSupport: bool,
+  @as("MAX_DATA_ID_LENGTH")
+  mutable maxDataIdLength: option<int>,
+  @as("REFACTOR_SUSPENSE_RESOURCE")
+  mutable refactorSuspenseResource: bool,
+  @as("STRING_INTERN_LEVEL")
+  mutable stringInternLevel: int,
+  @as("USE_REACT_CACHE")
+  mutable useReactCache: bool,
+}
+
+@module("relay-runtime")
+external relayFeatureFlags: featureFlags = "RelayFeatureFlags"
+
+@module("./utils")
+external convertObj: ('a, Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>>, 'b, 'c) => 'd = "traverser"
+
+let optArrayOfNullableToOptArrayOfOpt: option<array<Js.Nullable.t<'a>>> => option<
+  array<option<'a>>,
+> = x =>
+  switch x {
+  | None => None
+  | Some(arr) => Some(arr->Belt.Array.map(Js.Nullable.toOption))
+  }
+
+@module("relay-runtime") external storeRootId: dataId = "ROOT_ID"
+@module("relay-runtime") external storeRootType: string = "ROOT_TYPE"
+
+module RecordProxy = {
+  type t
+
+  @send
+  external copyFieldsFrom: (t, ~sourceRecord: t) => unit = "copyFieldsFrom"
+
+  @send external getDataId: t => dataId = "getDataID"
+
+  @send @return(nullable)
+  external getLinkedRecord: (t, ~name: string, ~arguments: arguments=?, unit) => option<t> =
+    "getLinkedRecord"
+
+  @send @return(nullable)
+  external getLinkedRecords: (t, string, option<arguments>) => option<array<Js.Nullable.t<t>>> =
+    "getLinkedRecords"
+
+  let getLinkedRecords = (t, ~name, ~arguments=?, ()): option<array<option<t>>> =>
+    getLinkedRecords(t, name, arguments)->optArrayOfNullableToOptArrayOfOpt
+
+  @send
+  external getOrCreateLinkedRecord: (
+    t,
+    ~name: string,
+    ~typeName: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "getOrCreateLinkedRecord"
+
+  @send external getType: t => string = "getType"
+
+  @send @return(nullable)
+  external getValueString: (t, ~name: string, ~arguments: arguments=?, unit) => option<string> =
+    "getValue"
+
+  @send @return(nullable)
+  external getValueStringArray: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<string>>> = "getValue"
+
+  @send @return(nullable)
+  external getValueInt: (t, ~name: string, ~arguments: arguments=?, unit) => option<int> =
+    "getValue"
+
+  @send @return(nullable)
+  external getValueIntArray: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<int>>> = "getValue"
+
+  @send @return(nullable)
+  external getValueFloat: (t, ~name: string, ~arguments: arguments=?, unit) => option<float> =
+    "getValue"
+
+  @send @return(nullable)
+  external getValueFloatArray: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<float>>> = "getValue"
+
+  @send @return(nullable)
+  external getValueBool: (t, ~name: string, ~arguments: arguments=?, unit) => option<bool> =
+    "getValue"
+
+  @send @return(nullable)
+  external getValueBoolArray: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<bool>>> = "getValue"
+
+  @send
+  external setLinkedRecord: (t, ~record: t, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setLinkedRecord"
+
+  // `setLinkedRecord` can't be used for "deleting" linked record fields.
+  // It throws an error if anything besides `record` is received:
+  // https://github.com/facebook/relay/blob/bd2e4173ef726804b2ed4e76d88a7bcc1753c496/packages/relay-runtime/mutations/RelayRecordProxy.js#L92
+  // However, `setValue` can be used for this purpose instead.
+  @send
+  external setLinkedRecordToUndefined: (
+    t,
+    @as(json`undefined`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setLinkedRecordToNull: (
+    t,
+    @as(json`null`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setLinkedRecords: (
+    t,
+    ~records: array<option<t>>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setLinkedRecords"
+
+  // `setLinkedRecords` can't be used for "deleting" linked records.
+  // It throws an error if anything besides an array of `records` is received:
+  // https://github.com/facebook/relay/blob/bd2e4173ef726804b2ed4e76d88a7bcc1753c496/packages/relay-runtime/mutations/RelayRecordProxy.js#L140
+  // However, `setValue` can be used for this purpose instead.
+  @send
+  external setLinkedRecordsToUndefined: (
+    t,
+    @as(json`undefined`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setLinkedRecordsToNull: (
+    t,
+    @as(json`null`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setValueToUndefined: (
+    t,
+    @as(json`undefined`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setValueToNull: (
+    t,
+    @as(json`null`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setValueString: (t, ~value: string, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setValue"
+
+  @send
+  external setValueStringArray: (
+    t,
+    ~value: array<string>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setValueInt: (t, ~value: int, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setValue"
+
+  @send
+  external setValueIntArray: (
+    t,
+    ~value: array<int>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setValueFloat: (t, ~value: float, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setValue"
+
+  @send
+  external setValueFloatArray: (
+    t,
+    ~value: array<float>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send
+  external setValueBool: (t, ~value: bool, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setValue"
+
+  @send
+  external setValueBoolArray: (
+    t,
+    ~value: array<bool>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  @send external invalidateRecord: t => unit = "invalidateRecord"
+}
+
+module RecordSourceSelectorProxy = {
+  type t
+
+  @send
+  external create: (t, ~dataId: dataId, ~typeName: string) => RecordProxy.t = "create"
+
+  @send external delete: (t, ~dataId: dataId) => unit = "delete"
+
+  @send @return(nullable)
+  external get: (t, ~dataId: dataId) => option<RecordProxy.t> = "get"
+
+  @send external getRoot: t => RecordProxy.t = "getRoot"
+
+  @send @return(nullable)
+  external getRootField: (t, ~fieldName: string) => option<RecordProxy.t> = "getRootField"
+
+  @send @return(nullable)
+  external getPluralRootField: (
+    t,
+    ~fieldName: string,
+  ) => option<array<Js.Nullable.t<RecordProxy.t>>> = "getPluralRootField"
+
+  let getPluralRootField = (t, ~fieldName): option<array<option<RecordProxy.t>>> =>
+    getPluralRootField(t, ~fieldName)->optArrayOfNullableToOptArrayOfOpt
+
+  @send external invalidateStore: t => unit = "invalidateStore"
+}
+
+module ReadOnlyRecordSourceProxy = {
+  type t
+
+  @send @return(nullable)
+  external get: (t, ~dataId: dataId) => option<RecordProxy.t> = "get"
+
+  @send external getRoot: t => RecordProxy.t = "getRoot"
+}
+
+module MissingFieldHandler = {
+  @@warning("-30")
+  type t
+
+  type normalizationArgumentWrapped = {kind: [#ListValue | #Literal | #ObjectValue | #Variable]}
+
+  type rec normalizationListValueArgument = {
+    name: string,
+    items: array<Js.Nullable.t<normalizationArgumentWrapped>>,
+  }
+  and normalizationLiteralArgument = {
+    name: string,
+    @as("type") type_: Js.Nullable.t<string>,
+    value: Js.Json.t,
+  }
+  and normalizationObjectValueArgument = {
+    name: string,
+    fields: Js.Nullable.t<array<normalizationArgumentWrapped>>,
+  }
+  and normalizationVariableArgument = {
+    name: string,
+    @as("type") type_: Js.Nullable.t<string>,
+    variableName: string,
+  }
+
+  type normalizationArgument =
+    | ListValue(normalizationListValueArgument)
+    | Literal(normalizationLiteralArgument)
+    | ObjectValue(normalizationObjectValueArgument)
+    | Variable(normalizationVariableArgument)
+
+  let unwrapNormalizationArgument = wrapped =>
+    switch wrapped.kind {
+    | #ListValue => ListValue(Obj.magic(wrapped))
+    | #Literal => Literal(Obj.magic(wrapped))
+    | #ObjectValue => ObjectValue(Obj.magic(wrapped))
+    | #Variable => Variable(Obj.magic(wrapped))
+    }
+
+  type normalizationScalarField = {
+    alias: Js.Nullable.t<string>,
+    name: string,
+    args: Js.Nullable.t<array<normalizationArgumentWrapped>>,
+    storageKey: Js.Nullable.t<string>,
+  }
+
+  let makeScalarMissingFieldHandler = handle =>
+    Obj.magic({
+      "kind": #scalar,
+      "handle": handle,
+    })
+
+  type normalizationLinkedField = {
+    alias: Js.Nullable.t<string>,
+    name: string,
+    storageKey: Js.Nullable.t<string>,
+    args: Js.Nullable.t<array<normalizationArgument>>,
+    concreteType: Js.Nullable.t<string>,
+    plural: bool,
+    selections: array<Js.Json.t>,
+  }
+
+  let makeLinkedMissingFieldHandler = handle =>
+    Obj.magic({
+      "kind": #linked,
+      "handle": handle,
+    })
+
+  let makePluralLinkedMissingFieldHandler = handle =>
+    Obj.magic({
+      "kind": #pluralLinked,
+      "handle": handle,
+    })
+}
+
+// This handler below enables automatic resolution of all cached items through the Node interface
+let nodeInterfaceMissingFieldHandler = MissingFieldHandler.makeLinkedMissingFieldHandler((
+  field,
+  record,
+  args,
+  _store,
+) =>
+  switch (Js.Nullable.toOption(record), field["name"], Js.Nullable.toOption(args["id"])) {
+  | (Some(record), "node", argsId) if record->RecordProxy.getType == storeRootType => argsId
+  | _ => None
+  }
+)
+
+module ConnectionHandler = {
+  @module("relay-runtime") @scope("ConnectionHandler") @return(nullable)
+  external getConnection: (
+    ~record: RecordProxy.t,
+    ~key: string,
+    ~filters: arguments=?,
+    unit,
+  ) => option<RecordProxy.t> = "getConnection"
+
+  @module("relay-runtime") @scope("ConnectionHandler")
+  external createEdge: (
+    ~store: RecordSourceSelectorProxy.t,
+    ~connection: RecordProxy.t,
+    ~node: RecordProxy.t,
+    ~edgeType: string,
+  ) => RecordProxy.t = "createEdge"
+
+  @module("relay-runtime") @scope("ConnectionHandler")
+  external insertEdgeBefore: (
+    ~connection: RecordProxy.t,
+    ~newEdge: RecordProxy.t,
+    ~cursor: string=?,
+    unit,
+  ) => unit = "insertEdgeBefore"
+
+  @module("relay-runtime") @scope("ConnectionHandler")
+  external insertEdgeAfter: (
+    ~connection: RecordProxy.t,
+    ~newEdge: RecordProxy.t,
+    ~cursor: string=?,
+    unit,
+  ) => unit = "insertEdgeAfter"
+
+  @module("relay-runtime") @scope("ConnectionHandler")
+  external deleteNode: (~connection: RecordProxy.t, ~nodeId: dataId) => unit = "deleteNode"
+
+  @module("relay-runtime") @scope("ConnectionHandler")
+  external getConnectionID: (dataId, string, 'filters) => dataId = "getConnectionID"
+}
+
+type operationDescriptor
+
+module Disposable = {
+  type t
+
+  @send external dispose: t => unit = "dispose"
+  external ignore: t => unit = "%ignore"
+}
+
+type cacheConfig = {
+  force: option<bool>,
+  poll: option<int>,
+  liveConfigId: option<string>,
+  transactionId: option<string>,
+}
+
+module Observable = {
+  type t<'response>
+
+  type subscription = {
+    unsubscribe: unit => unit,
+    closed: bool,
+  }
+
+  type sink<'response> = {
+    next: 'response => unit,
+    error: Js.Exn.t => unit,
+    complete: unit => unit,
+    closed: bool,
+  }
+
+  type observer<'response>
+
+  @obj
+  external makeObserver: (
+    ~start: subscription => unit=?,
+    ~next: 'response => unit=?,
+    ~error: Js.Exn.t => unit=?,
+    ~complete: unit => unit=?,
+    ~unsubscribe: subscription => unit=?,
+    unit,
+  ) => observer<'response> = ""
+
+  @module("relay-runtime") @scope("Observable")
+  external make: (sink<'response> => option<subscription>) => t<'response> = "create"
+
+  @send
+  external subscribe: (t<'response>, observer<'response>) => subscription = "subscribe"
+
+  @send external toPromise: t<'t> => Js.Promise.t<'t> = "toPromise"
+
+  external ignoreSubscription: subscription => unit = "%ignore"
+}
+
+module Network = {
+  type t
+
+  type operation = {
+    id: string,
+    text: string,
+    name: string,
+    operationKind: string,
+  }
+
+  type subscribeFn = (operation, Js.Json.t, cacheConfig) => Observable.t<Js.Json.t>
+
+  type fetchFunctionPromise = (
+    operation,
+    Js.Json.t,
+    cacheConfig,
+    Js.Nullable.t<uploadables>,
+  ) => Js.Promise.t<Js.Json.t>
+
+  type fetchFunctionObservable = (
+    operation,
+    Js.Json.t,
+    cacheConfig,
+    Js.Nullable.t<uploadables>,
+  ) => Observable.t<Js.Json.t>
+
+  @module("relay-runtime") @scope("Network")
+  external makePromiseBased: (
+    ~fetchFunction: fetchFunctionPromise,
+    ~subscriptionFunction: subscribeFn=?,
+    unit,
+  ) => t = "create"
+
+  @module("relay-runtime") @scope("Network")
+  external makeObservableBased: (
+    ~observableFunction: fetchFunctionObservable,
+    ~subscriptionFunction: subscribeFn=?,
+    unit,
+  ) => t = "create"
+}
+
+module RecordSource = {
+  type t
+
+  @module("relay-runtime") @new
+  external make: (~records: recordSourceRecords=?, unit) => t = "RecordSource"
+
+  @send external toJSON: t => recordSourceRecords = "toJSON"
+}
+
+module Store = {
+  type t
+
+  type storeConfig = {
+    gcReleaseBufferSize: option<int>,
+    queryCacheExpirationTime: option<int>,
+  }
+
+  @module("relay-runtime") @new
+  external make: (RecordSource.t, storeConfig) => t = "Store"
+
+  let make = (~source, ~gcReleaseBufferSize=?, ~queryCacheExpirationTime=?, ()) =>
+    make(
+      source,
+      {
+        gcReleaseBufferSize,
+        queryCacheExpirationTime,
+      },
+    )
+
+  @send external getSource: t => RecordSource.t = "getSource"
+  @send external publish: (t, RecordSource.t) => unit = "publish"
+  @send external holdGC: t => unit = "holdGC"
+}
+
+module RequiredFieldLogger = {
+  type kind = [#"missing_field.log" | #"missing_field.throw"]
+
+  type arg = {"kind": kind, "owner": string, "fieldPath": string}
+
+  type js = arg => unit
+
+  type t = (~kind: kind, ~owner: string, ~fieldPath: string) => unit
+
+  let toJs: t => js = f => arg =>
+    f(~kind=arg["kind"], ~owner=arg["owner"], ~fieldPath=arg["fieldPath"])
+}
+
+module Environment = {
+  type t
+
+  @deriving(abstract)
+  type environmentConfig<'a> = {
+    network: Network.t,
+    store: Store.t,
+    @optional
+    getDataID: (~nodeObj: 'a, ~typeName: string) => string,
+    @optional
+    treatMissingFieldsAsNull: bool,
+    missingFieldHandlers: array<MissingFieldHandler.t>,
+    @optional
+    requiredFieldLogger: RequiredFieldLogger.js,
+    @optional
+    isServer: bool,
+  }
+
+  @module("relay-runtime") @new
+  external make: environmentConfig<'a> => t = "Environment"
+
+  let make = (
+    ~network,
+    ~store,
+    ~getDataID=?,
+    ~treatMissingFieldsAsNull=?,
+    ~missingFieldHandlers=?,
+    ~requiredFieldLogger=?,
+    ~isServer=?,
+    (),
+  ) =>
+    make(
+      environmentConfig(
+        ~network,
+        ~store,
+        ~getDataID?,
+        ~treatMissingFieldsAsNull?,
+        ~missingFieldHandlers=switch missingFieldHandlers {
+        | Some(handlers) => handlers->Belt.Array.concat([nodeInterfaceMissingFieldHandler])
+        | None => [nodeInterfaceMissingFieldHandler]
+        },
+        ~requiredFieldLogger=?requiredFieldLogger->Belt.Option.map(RequiredFieldLogger.toJs),
+        ~isServer?,
+        (),
+      ),
+    )
+
+  @send external getStore: t => Store.t = "getStore"
+  @send
+  external commitPayload: (t, operationDescriptor, 'payload) => unit = "commitPayload"
+  @send external retain: (t, operationDescriptor) => Disposable.t = "retain"
+}
+
+module Context = {
+  type t
+
+  type contextShape = {"environment": Environment.t}
+
+  @module("react-relay")
+  external context: React.Context.t<option<contextShape>> = "ReactRelayContext"
+
+  module Provider = {
+    @react.component
+    let make = (~environment: Environment.t, ~children) => {
+      let provider = React.Context.provider(context)
+      React.createElement(provider, {value: Some({"environment": environment}), children})
+    }
+  }
+}
+
+exception EnvironmentNotFoundInContext
+
+let useEnvironmentFromContext = () => {
+  let context = React.useContext(Context.context)
+
+  switch context {
+  | Some(ctx) => ctx["environment"]
+  | None => raise(EnvironmentNotFoundInContext)
+  }
+}
+
+type fetchPolicy =
+  | @as("store-only") StoreOnly
+  | @as("store-or-network") StoreOrNetwork
+  | @as("store-and-network") StoreAndNetwork
+  | @as("network-only") NetworkOnly
+
+type fetchQueryFetchPolicy =
+  | @as("network-only") NetworkOnly
+  | @as("store-or-network") StoreOrNetwork
+
+type fetchQueryOptions = {
+  networkCacheConfig?: cacheConfig,
+  fetchPolicy?: fetchPolicy,
+}
+
+type loadQueryConfig = {
+  fetchKey: option<string>,
+  fetchPolicy: option<fetchPolicy>,
+  networkCacheConfig: option<cacheConfig>,
+}
+
+@module("react-relay")
+external loadQuery: (Environment.t, queryNode<'a>, 'variables, loadQueryConfig) => 'queryResponse =
+  "loadQuery"
+
+module type MakeLoadQueryConfig = {
+  type variables
+  type loadedQueryRef
+  type response
+  type node
+  let query: queryNode<node>
+  let convertVariables: variables => variables
+}
+
+module MakeLoadQuery = (C: MakeLoadQueryConfig) => {
+  let load: (
+    ~environment: Environment.t,
+    ~variables: C.variables,
+    ~fetchPolicy: fetchPolicy=?,
+    ~fetchKey: string=?,
+    ~networkCacheConfig: cacheConfig=?,
+    unit,
+  ) => C.loadedQueryRef = (
+    ~environment,
+    ~variables,
+    ~fetchPolicy=?,
+    ~fetchKey=?,
+    ~networkCacheConfig=?,
+    (),
+  ) =>
+    loadQuery(
+      environment,
+      C.query,
+      variables->C.convertVariables,
+      {
+        fetchKey,
+        fetchPolicy,
+        networkCacheConfig,
+      },
+    )
+
+  type rawPreloadToken<'response> = {source: Js.Nullable.t<Observable.t<'response>>}
+  external tokenToRaw: C.loadedQueryRef => rawPreloadToken<C.response> = "%identity"
+
+  let queryRefToObservable = token => {
+    let raw = token->tokenToRaw
+    raw.source->Js.Nullable.toOption
+  }
+
+  let queryRefToPromise = token => {
+    Js.Promise.make((~resolve, ~reject as _) => {
+      switch token->queryRefToObservable {
+      | None => resolve(Error())
+      | Some(o) =>
+        open Observable
+        let _: subscription = o->subscribe(makeObserver(~complete=() => resolve(Ok()), ()))
+      }
+    })
+  }
+}
+
+type mutationError = {message: string}
+
+exception Mutation_failed(array<mutationError>)
+
+@module("relay-runtime")
+external commitLocalUpdate: (
+  ~environment: Environment.t,
+  ~updater: RecordSourceSelectorProxy.t => unit,
+) => unit = "commitLocalUpdate"
+
+@module("react-relay")
+external useSubscribeToInvalidationState: (array<dataId>, unit => unit) => Disposable.t =
+  "useSubscribeToInvalidationState"
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay.resi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.resi
new file mode 100644
index 0000000..0f3ae7b
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay.resi
@@ -0,0 +1,870 @@
+/**Abstract type for arguments, used when selecting fields on `RecordProxy` and friends when interacting with the store imperatively.*/
+type arguments
+
+/**Abstract type for uploadables.
+
+### Constructing an `uploadables`
+Use `makeUploadable`: `makeUploadable({ "someFile": theFileYouWantToUpload })` to construct an `uploadables`, and then pass it to your mutation via the `uploadables` prop.
+
+Please note that you'll need to handle _sending_ the uploadables to your server yourself in the network layer. [Here's an example](https://github.com/facebook/relay/issues/1844#issuecomment-316893590) in regular JS that you can adapt to ReScript as you need/want.*/
+type uploadables
+
+/**If you see this, it means that all fields have been masked in this selection, which is why it contains no data. Relay uses [_data masking_](https://relay.dev/docs/en/thinking-in-relay.html#data-masking) to hide data you haven't explicitly asked for, even if it exists on the object.*/
+type allFieldsMasked = {.}
+
+/**Abstract helper type to signify something that could not be generated in a type-safe way.*/
+type any
+
+/**A query node, used internally by Relay. These are runtime artifacts produced by the Relay compiler.*/
+type queryNode<'node>
+
+/**A fragment node, used internally by Relay. These are runtime artifacts produced by the Relay compiler.*/
+type fragmentNode<'node>
+
+/**A mutation node, used internally by Relay. These are runtime artifacts produced by the Relay compiler.*/
+type mutationNode<'node>
+
+/**A subscription node, used internally by Relay. These are runtime artifacts produced by the Relay compiler.*/
+type subscriptionNode<'node>
+
+/**This type shows all of the fragments that has been spread on this particular object.*/
+type fragmentRefs<'fragments>
+
+/**The type of the id Relay uses to identify records in its store.*/
+type dataId
+
+/**Turns a `dataId` into a `string`.*/
+external dataIdToString: dataId => string = "%identity"
+
+/**Turns a `string` into a `dataId`.*/
+external makeDataId: string => dataId = "%identity"
+
+/**Construct an `arguments` object for use with certain Relay store APIs.
+
+### Usage
+Use it like this: `makeArguments({ "someArgument": someValue, "anotherArgument": anotherValue })`. Notice the "" surrounding the property names - these are important and tells ReScript that we want this to be a JS object.*/
+external makeArguments: {..} => arguments = "%identity"
+
+/**Construct an `uploadables` object from a `Js.Dict` with your desired file format, that you can use for uploads via Relay.*/
+external makeUploadables: Js.Dict.t<'file> => uploadables = "%identity"
+
+/**Unwraps `uploadables` into a Js.Dict.t with your expected file type, so you can use that dict to attach the provided files to your request.*/
+external unwrapUploadables: uploadables => Js.Dict.t<'file> = "%identity"
+
+/**This generates a `dataId` for use on the _client_ side. However, this is farily low level, and what you're probably really looking for is `generateUniqueClientID` that'll let you generate a new, unique `dataId` that you can use for client side only records (like when doing optimistic updates).*/
+@module("relay-runtime")
+external generateClientID: (~dataId: dataId, ~storageKey: string, ~index: int=?, unit) => dataId =
+  "generateClientID"
+
+/**This generates a unique `dataId` that's safe to use on the _client_ side. Useful when doing optimistic updates and you need to create IDs that the optimistic update can use.*/
+@module("relay-runtime")
+external generateUniqueClientID: unit => dataId = "generateUniqueClientID"
+
+/**Checks whether the provided `dataId` is guaranteed to be a client side only id.*/
+@module("relay-runtime")
+external isClientID: dataId => bool = "isClientID"
+
+/**Relay feature flags. Mutate this record as soon as your application boots to enable/disable features.*/
+type featureFlags = {
+  @as("DELAY_CLEANUP_OF_PENDING_PRELOAD_QUERIES")
+  mutable delayCleanupOfPendingPreloadQueries: bool,
+  @as("ENABLE_CLIENT_EDGES")
+  mutable enableClientEdges: bool,
+  @as("ENABLE_VARIABLE_CONNECTION_KEY")
+  mutable enableVariableConnectionKey: bool,
+  @as("ENABLE_PARTIAL_RENDERING_DEFAULT")
+  mutable enablePartialRenderingDefault: bool,
+  @as("ENABLE_REACT_FLIGHT_COMPONENT_FIELD")
+  mutable enableReactFlightComponentField: bool,
+  @as("ENABLE_RELAY_RESOLVERS")
+  mutable enableRelayResolvers: bool,
+  @as("ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION")
+  mutable enableGetFragmentIdentifierOptimization: bool,
+  @as("ENABLE_FRIENDLY_QUERY_NAME_GQL_URL")
+  mutable enableFriendlyQueryNameGqlUrl: bool,
+  @as("ENABLE_LOAD_QUERY_REQUEST_DEDUPING")
+  mutable enableLoadQueryRequestDeduping: bool,
+  @as("ENABLE_DO_NOT_WRAP_LIVE_QUERY")
+  mutable enableDoNotWrapLiveQuery: bool,
+  @as("ENABLE_NOTIFY_SUBSCRIPTION")
+  mutable enableNotifySubscription: bool,
+  @as("ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT")
+  mutable enableContainersSubscribeOnCommit: bool,
+  @as("ENABLE_QUERY_RENDERER_OFFSCREEN_SUPPORT")
+  mutable enableQueryRendererOffscreenSupport: bool,
+  @as("MAX_DATA_ID_LENGTH")
+  mutable maxDataIdLength: option<int>,
+  @as("REFACTOR_SUSPENSE_RESOURCE")
+  mutable refactorSuspenseResource: bool,
+  @as("STRING_INTERN_LEVEL")
+  mutable stringInternLevel: int,
+  @as("USE_REACT_CACHE")
+  mutable useReactCache: bool,
+}
+
+/**Relay feature flags. Mutate this record as soon as your application boots to enable/disable features.*/
+@module("relay-runtime")
+external relayFeatureFlags: featureFlags = "RelayFeatureFlags"
+
+/**Representing all records in the store serialized to JSON in a way that you can use to re-hydrate the store. 
+
+See `RecordSource.toJSON` for how to produce it.*/
+type recordSourceRecords = Js.Json.t
+
+/**The `dataId` for the Relay store's root. Useful when for example referencing the `parentID` of a connection that's on the store root.*/
+@module("relay-runtime")
+external storeRootId: dataId = "ROOT_ID"
+
+/**The `type` for the Relay store's root `RecordProxy`.*/
+@module("relay-runtime")
+external storeRootType: string = "ROOT_TYPE"
+
+/**Internal, do not use.*/
+@module("./utils")
+external convertObj: ('a, Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>>, 'b, 'c) => 'd = "traverser"
+
+/**Read the following section on working with the Relay store: https://relay.dev/docs/en/relay-store*/
+module RecordProxy: {
+  /**Read the following section on working with the Relay store: https://relay.dev/docs/en/relay-store*/
+  type t
+
+  /**Copies all fields from one `RecordProxy` to another.*/
+  @send
+  external copyFieldsFrom: (t, ~sourceRecord: t) => unit = "copyFieldsFrom"
+
+  /**Gets the `dataId` for a particular record.*/
+  @send
+  external getDataId: t => dataId = "getDataID"
+
+  /**Gets a single linked record. A linked record is another object in the store, and not a scalar field like an int or float.*/
+  @send
+  @return(nullable)
+  external getLinkedRecord: (t, ~name: string, ~arguments: arguments=?, unit) => option<t> =
+    "getLinkedRecord"
+
+  /**Gets an array of linked records, for when a field is a list (meaning a link to multiple records).*/
+  let getLinkedRecords: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<t>>>
+
+  /**This returns an existing linked record, or creates one at the configured place if one does not already exist.*/
+  @send
+  external getOrCreateLinkedRecord: (
+    t,
+    ~name: string,
+    ~typeName: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "getOrCreateLinkedRecord"
+
+  /**Returns the `__typename` of this particular record.*/
+  @send
+  external getType: t => string = "getType"
+
+  /**Returns a field value, expecting it to be a string.*/
+  @send
+  @return(nullable)
+  external getValueString: (t, ~name: string, ~arguments: arguments=?, unit) => option<string> =
+    "getValue"
+
+  /**Returns a field value, expecting it to be an array of strings.*/
+  @send
+  @return(nullable)
+  external getValueStringArray: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<string>>> = "getValue"
+
+  /**Returns a field value, expecting it to be an int.*/
+  @send
+  @return(nullable)
+  external getValueInt: (t, ~name: string, ~arguments: arguments=?, unit) => option<int> =
+    "getValue"
+
+  /**Returns a field value, expecting it to be an array of ints.*/
+  @send
+  @return(nullable)
+  external getValueIntArray: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<int>>> = "getValue"
+
+  /**Returns a field value, expecting it to be a float.*/
+  @send
+  @return(nullable)
+  external getValueFloat: (t, ~name: string, ~arguments: arguments=?, unit) => option<float> =
+    "getValue"
+
+  /**Returns a field value, expecting it to be an array of floats.*/
+  @send
+  @return(nullable)
+  external getValueFloatArray: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<float>>> = "getValue"
+
+  /**Returns a field value, expecting it to be a boolean.*/
+  @send
+  @return(nullable)
+  external getValueBool: (t, ~name: string, ~arguments: arguments=?, unit) => option<bool> =
+    "getValue"
+
+  /**Returns a field value, expecting it to be an array of booleans.*/
+  @send
+  @return(nullable)
+  external getValueBoolArray: (
+    t,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => option<array<option<bool>>> = "getValue"
+
+  /**Sets a `RecordProxy.t` as the linked record for a particular field.*/
+  @send
+  external setLinkedRecord: (t, ~record: t, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setLinkedRecord"
+
+  /**Sets an array of `RecordProxy.t` as the linked records for a particular field.*/
+  @send
+  external setLinkedRecords: (
+    t,
+    ~records: array<option<t>>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setLinkedRecords"
+
+  /**Sets a string as field value.*/
+  @send
+  external setValueString: (t, ~value: string, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setValue"
+
+  /**Sets an array of strings as field value.*/
+  @send
+  external setValueStringArray: (
+    t,
+    ~value: array<string>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets an int as field value.*/
+  @send
+  external setValueInt: (t, ~value: int, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setValue"
+
+  /**Sets an array of ints as field value.*/
+  @send
+  external setValueIntArray: (
+    t,
+    ~value: array<int>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets a float as field value.*/
+  @send
+  external setValueFloat: (t, ~value: float, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setValue"
+
+  /**Sets an array of floats as field value.*/
+  @send
+  external setValueFloatArray: (
+    t,
+    ~value: array<float>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets a boolean as field value.*/
+  @send
+  external setValueBool: (t, ~value: bool, ~name: string, ~arguments: arguments=?, unit) => t =
+    "setValue"
+
+  /**Sets an array of booleans as field value.*/
+  @send
+  external setValueBoolArray: (
+    t,
+    ~value: array<bool>,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets the field value to `undefined` (meaning Relay will treat it as missing data).*/
+  @send
+  external setValueToUndefined: (
+    t,
+    @as(json`undefined`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets the field value to `null`.*/
+  @send
+  external setValueToNull: (
+    t,
+    @as(json`null`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets this linked record to `undefined` (meaning Relay will treat it as missing data).*/
+  @send
+  external setLinkedRecordToUndefined: (
+    t,
+    @as(json`undefined`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets this linked record to `null`.*/
+  @send
+  external setLinkedRecordToNull: (
+    t,
+    @as(json`null`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets the field holding these linked records to `undefined` (meaning Relay will treat it as missing data).*/
+  @send
+  external setLinkedRecordsToUndefined: (
+    t,
+    @as(json`undefined`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Sets the field holding these linked records to `null`.*/
+  @send
+  external setLinkedRecordsToNull: (
+    t,
+    @as(json`null`) _,
+    ~name: string,
+    ~arguments: arguments=?,
+    unit,
+  ) => t = "setValue"
+
+  /**Invalidates this record.
+
+Invalidating a record means that the _next_ time Relay evaluates this record, it'll be treated as missing.
+
+_Beware_ that this doesn't mean that queries using this record will refetch immediately. Rather, it'll happen the next time the query _renders_. Have a look at `useSubscribeToInvalidationState`, that'll allow you to subscribe to whenever records are invalidated, if you're looking for a way to refetch immediately as something invalidates.*/
+  @send
+  external invalidateRecord: t => unit = "invalidateRecord"
+}
+
+/**RecordSourceSelectorProxy and RecordSourceProxy are the two modules representing the store, with various capabilities.*/
+module RecordSourceSelectorProxy: {
+  /**Type type representing a `RecordSourceSelectorProxy`.*/
+  type t
+
+  /**Creates a new `RecordProxy`.*/
+  @send
+  external create: (t, ~dataId: dataId, ~typeName: string) => RecordProxy.t = "create"
+
+  /**Deletes the `RecordProxy` with the provided `dataId`.*/
+  @send
+  external delete: (t, ~dataId: dataId) => unit = "delete"
+
+  /**Returns the `RecordProxy` with the provided `dataId`, if it exists.*/
+  @send
+  @return(nullable)
+  external get: (t, ~dataId: dataId) => option<RecordProxy.t> = "get"
+
+  /**Returns the _root_ `RecordProxy`, meaning the `RecordProxy` holding your top level fields.*/
+  @send
+  external getRoot: t => RecordProxy.t = "getRoot"
+
+  /**Returns the `RecordProxy` for the `fieldName` at root. You should prefer using `RecordSourceSelectorProxy.getRoot()` and traverse from there if you need access to root fields rather than use this.*/
+  @send
+  @return(nullable)
+  external getRootField: (t, ~fieldName: string) => option<RecordProxy.t> = "getRootField"
+
+  /**Plural version of `RecordSourceSelectorProxy.getRootField`.*/
+  let getPluralRootField: (t, ~fieldName: string) => option<array<option<RecordProxy.t>>>
+
+  /**Invalidates the entire store. This means that _at the next render_, the entire store will be treated as empty, meaning Relay will refetch everything it needs to show the view it's to show.*/
+  @send
+  external invalidateStore: t => unit = "invalidateStore"
+}
+
+/**ReadOnlyRecordSourceProxy is the store, but in read-only mode.*/
+module ReadOnlyRecordSourceProxy: {
+  /**Type type representing a `ReadOnlyRecordSourceProxy`.*/
+  type t
+
+  /**Returns the `RecordProxy` with the provided `dataId`, if it exists.*/
+  @send
+  @return(nullable)
+  external get: (t, ~dataId: dataId) => option<RecordProxy.t> = "get"
+
+  /**Returns the _root_ `RecordProxy`, meaning the `RecordProxy` holding your top level fields.*/
+  @send
+  external getRoot: t => RecordProxy.t = "getRoot"
+}
+
+/**A missing field handler, which is a way of teaching Relay more about the relations in your schema, so it can fulfill more things from the cache. Read more [in this section of the Relay docs](https://relay.dev/docs/guided-tour/reusing-cached-data/filling-in-missing-data/).
+
+Feed a list of missing field handlers into `Environment.make` if you want to use them.*/
+module MissingFieldHandler: {
+  @@warning("-30")
+
+  /**A missing field handler, which is a way of teaching Relay more about the relations in your schema, so it can fulfill more things from the cache. Read more [in this section of the Relay docs](https://relay.dev/docs/guided-tour/reusing-cached-data/filling-in-missing-data/).*/
+  type t
+
+  type normalizationArgumentWrapped = {kind: [#ListValue | #Literal | #ObjectValue | #Variable]}
+
+  type rec normalizationListValueArgument = {
+    name: string,
+    items: array<Js.Nullable.t<normalizationArgumentWrapped>>,
+  }
+  and normalizationLiteralArgument = {
+    name: string,
+    @as("type") type_: Js.Nullable.t<string>,
+    value: Js.Json.t,
+  }
+  and normalizationObjectValueArgument = {
+    name: string,
+    fields: Js.Nullable.t<array<normalizationArgumentWrapped>>,
+  }
+  and normalizationVariableArgument = {
+    name: string,
+    @as("type") type_: Js.Nullable.t<string>,
+    variableName: string,
+  }
+
+  type normalizationArgument =
+    | ListValue(normalizationListValueArgument)
+    | Literal(normalizationLiteralArgument)
+    | ObjectValue(normalizationObjectValueArgument)
+    | Variable(normalizationVariableArgument)
+
+  let unwrapNormalizationArgument: normalizationArgumentWrapped => normalizationArgument
+
+  type normalizationScalarField = {
+    alias: Js.Nullable.t<string>,
+    name: string,
+    args: Js.Nullable.t<array<normalizationArgumentWrapped>>,
+    storageKey: Js.Nullable.t<string>,
+  }
+
+  /**Make a `MissingFieldHandler.t` for scalar fields. Give this a handler function that returns `Js.null` (to indicate that data exists but is null), `Js.undefined` (to indicate data is still missing), or a scalar value (to indicate that the value exists even though it's not in the cache, and is the value you send back).*/
+  let makeScalarMissingFieldHandler: (
+    (
+      normalizationScalarField,
+      Js.Nullable.t<'record>,
+      'args,
+      ReadOnlyRecordSourceProxy.t,
+    ) => 'scalarValue
+  ) => t
+
+  type normalizationLinkedField = {
+    alias: Js.Nullable.t<string>,
+    name: string,
+    storageKey: Js.Nullable.t<string>,
+    args: Js.Nullable.t<array<normalizationArgument>>,
+    concreteType: Js.Nullable.t<string>,
+    plural: bool,
+    selections: array<Js.Json.t>,
+  }
+
+  /**Make a `MissingFieldHandler.t` for linked fields (other objects/records). Give this a handler function that returns `Js.null` (to indicate that the link exists but the linked record is null), `Js.undefined` (to indicate data is still missing), or a `dataId` of the record that is linked at this field.*/
+  let makeLinkedMissingFieldHandler: (
+    (
+      normalizationLinkedField,
+      Js.Nullable.t<RecordProxy.t>,
+      'args,
+      ReadOnlyRecordSourceProxy.t,
+    ) => Js.Nullable.t<dataId>
+  ) => t
+
+  /**Make a `MissingFieldHandler.t` for lists of linked fields (other objects/records). Give this a handler function that returns `Js.null` (to indicate that the link exists but the linked record is null), `Js.undefined` (to indicate data is still missing), or an array of `Js.Nullable.t<dataId>` where the `dataId`'s are the linked records/objects.*/
+  let makePluralLinkedMissingFieldHandler: (
+    (
+      normalizationLinkedField,
+      Js.Nullable.t<RecordProxy.t>,
+      'args,
+      ReadOnlyRecordSourceProxy.t,
+    ) => Js.Nullable.t<array<Js.Nullable.t<dataId>>>
+  ) => t
+}
+
+/**Read the Relay docs section on [ConnectionHandler](https://relay.dev/docs/en/relay-store#connectionhandler)*/
+module ConnectionHandler: {
+  /**For a `RecordProxy`, returns the `RecordProxy` that is at the connection config provided.*/
+  @module("relay-runtime")
+  @scope("ConnectionHandler")
+  @return(nullable)
+  external getConnection: (
+    ~record: RecordProxy.t,
+    ~key: string,
+    ~filters: arguments=?,
+    unit,
+  ) => option<RecordProxy.t> = "getConnection"
+
+  /**Creates an edge for a particular connection.*/
+  @module("relay-runtime")
+  @scope("ConnectionHandler")
+  external createEdge: (
+    ~store: RecordSourceSelectorProxy.t,
+    ~connection: RecordProxy.t,
+    ~node: RecordProxy.t,
+    ~edgeType: string,
+  ) => RecordProxy.t = "createEdge"
+
+  /**Inserts an edge into a connection _before_ the provided cursor. If no cursor is provided, it inserts the edge at the start of the connection list.*/
+  @module("relay-runtime")
+  @scope("ConnectionHandler")
+  external insertEdgeBefore: (
+    ~connection: RecordProxy.t,
+    ~newEdge: RecordProxy.t,
+    ~cursor: string=?,
+    unit,
+  ) => unit = "insertEdgeBefore"
+
+  /**Inserts an edge into a connection _after_ the provided cursor. If no cursor is provided, it inserts the edge at the end of the connection list.*/
+  @module("relay-runtime")
+  @scope("ConnectionHandler")
+  external insertEdgeAfter: (
+    ~connection: RecordProxy.t,
+    ~newEdge: RecordProxy.t,
+    ~cursor: string=?,
+    unit,
+  ) => unit = "insertEdgeAfter"
+
+  /**Deletes any edge from the connection where the node of the edge has the provided `dataId`. Please not that this _will not_ remove the actual node from the store. Use `RecordSourceSelectorProxy.delete` for that.*/
+  @module("relay-runtime")
+  @scope("ConnectionHandler")
+  external deleteNode: (~connection: RecordProxy.t, ~nodeId: dataId) => unit = "deleteNode"
+
+  /**Constructs a `dataId` targeting a specific connection at a specific parent. Note that the generated module for every fragment with a `@connection` will have a `<moduleName>.Utils.connectionKey` representing the connection key of that particular `@connection`, that you should use with this.*/
+  @module("relay-runtime")
+  @scope("ConnectionHandler")
+  external getConnectionID: (dataId, string, 'filters) => dataId = "getConnectionID"
+}
+
+/**The cache config provided to the network layer. Relay won't do anything in particular with these, it's up to you to use them if you want inside of your `NetworkLayer`.*/
+type cacheConfig = {
+  force: option<bool>,
+  poll: option<int>,
+  liveConfigId: option<string>,
+  transactionId: option<string>,
+}
+
+/**A Relay observable, used throughout Relay for delivering data, in particular when dealing with multiple payloads like with subscriptions or multipart responses like `@stream` or `@defer`.*/
+module Observable: {
+  /**The type representing the observable.*/
+  type t<'response>
+
+  /**This sink can be used to give the observable new data.*/
+  type sink<'response> = {
+    next: 'response => unit,
+    error: Js.Exn.t => unit,
+    complete: unit => unit,
+    closed: bool,
+  }
+
+  /**A subscription for an observable, allowing you to unsubscribe if wanted.*/
+  type subscription = {
+    unsubscribe: unit => unit,
+    closed: bool,
+  }
+
+  /**An observer of the observable.*/
+  type observer<'response>
+
+  /**Create an observer.*/
+  @obj
+  external makeObserver: (
+    ~start: subscription => unit=?,
+    ~next: 'response => unit=?,
+    ~error: Js.Exn.t => unit=?,
+    ~complete: unit => unit=?,
+    ~unsubscribe: subscription => unit=?,
+    unit,
+  ) => observer<'response> = ""
+
+  /**Create a new observable, getting fed an `Observable.sink` for interacting with the observable, and optionally returning a `Observable.subscription` if you have things you want to unsubscribe from as the observable closes.*/
+  @module("relay-runtime")
+  @scope("Observable")
+  external make: (sink<'t> => option<subscription>) => t<'t> = "create"
+
+  /**Subscribe to the `Observable.t` using an observer.*/
+  @send
+  external subscribe: (t<'t>, observer<'t>) => subscription = "subscribe"
+
+  /**Turns an `Observable` into a promise. _Beware_ that reading the response in the resulting promise is currently _not safe_ due to some internals of how ReScript Relay works. This will be resolved in the future.*/
+  @send
+  external toPromise: t<'t> => Js.Promise.t<'t> = "toPromise"
+
+  /**Ignore this subscription.*/ external ignoreSubscription: subscription => unit = "%ignore"
+}
+
+/**Represents the network layer.*/
+module Network: {
+  /**The type representing an instantiated `NetworkLayer`.*/
+  type t
+
+  /**The operation fed to the `NetworkLayer` when Relay wants to make a request. Please note that if you're using persisted queries, `id` will exist but `text` won't, and vice versa when not using persisted queries.*/
+  type operation = {
+    id: string,
+    text: string,
+    name: string,
+    operationKind: string,
+  }
+
+  /**The shape of the function Relay expects for creating a subscription.*/
+  type subscribeFn = (operation, Js.Json.t, cacheConfig) => Observable.t<Js.Json.t>
+
+  /**The shape of the function responsible for fetching data if you want to return a promise rather than an `Observable`.*/
+  type fetchFunctionPromise = (
+    operation,
+    Js.Json.t,
+    cacheConfig,
+    Js.Nullable.t<uploadables>,
+  ) => Js.Promise.t<Js.Json.t>
+
+  /**The shape of the function responsible for fetching data if you want to return an `Observable`.*/
+  type fetchFunctionObservable = (
+    operation,
+    Js.Json.t,
+    cacheConfig,
+    Js.Nullable.t<uploadables>,
+  ) => Observable.t<Js.Json.t>
+
+  /**Create a new `NetworkLayer` using a fetch function that returns a promise.*/
+  @module("relay-runtime")
+  @scope("Network")
+  external makePromiseBased: (
+    ~fetchFunction: fetchFunctionPromise,
+    ~subscriptionFunction: subscribeFn=?,
+    unit,
+  ) => t = "create"
+
+  /**Create a new `NetworkLayer` using a fetch function that returns an `Observable`.*/
+  @module("relay-runtime")
+  @scope("Network")
+  external makeObservableBased: (
+    ~observableFunction: fetchFunctionObservable,
+    ~subscriptionFunction: subscribeFn=?,
+    unit,
+  ) => t = "create"
+}
+
+/**RecordSource is the source of records used by the store. Can be initiated with or without prior records; eg. hydrating the store with prior data.*/
+module RecordSource: {
+  /**The type representing an instantiated `RecordSource`.*/
+  type t
+
+  /**Create a new `RecordSource`. Here's where you pass an existing `recordSourceRecords` if you have existing records you want to hydrate the store with, when doing SSR or similar.*/
+  @module("relay-runtime")
+  @new
+  external make: (~records: recordSourceRecords=?, unit) => t = "RecordSource"
+
+  /**Serializes the `RecordSource` into `recordSourceRecords` that you can use to rehydrate another store. Typically used for SSR.*/
+  @send
+  external toJSON: t => recordSourceRecords = "toJSON"
+}
+
+/**The actual store module, with configuration for the store.*/
+module Store: {
+  /**The type representing an instantiated `Store`.*/
+  type t
+
+  /**Creates a new `Store`.*/
+  let make: (
+    ~source: RecordSource.t,
+    ~gcReleaseBufferSize: /* `gcReleaseBufferSize` controls how many queries are allowed to be cached by default. Increase this to increase the size of the cache. */
+    int=?,
+    ~queryCacheExpirationTime: int=? /* `queryCacheExpirationTime` sets a TTL (time to live) for all queries. If that time passes, the data is considered stale and is evicted from the store. Default is no TTL. */,
+    unit,
+  ) => t
+
+  /**Gets the `RecordSource` for this `Store`.*/
+  @send
+  external getSource: t => RecordSource.t = "getSource"
+
+  /**Publishes _new_ records to this store. This is useful in particular with frameworks like Next.js where routes could preload data needed and then serialize that (using `RecordSource.toJSON`) and send it over the wire, but you already have a store instantiated client side. This will then allow you to publish those records into your existing store.*/
+  @send
+  external publish: (t, RecordSource.t) => unit = "publish"
+
+  /**Informes the store to stop its normal garbage collection processes. This prevents data being lost between calling relay's `fetchQuery` any serialization process (eg: toJSON)*/
+  @send
+  external holdGC: t => unit = "holdGC"
+}
+
+/**Internal, do not use.*/
+type operationDescriptor
+
+/**A disposable is something you can use to dispose of something when you don't use/need it anymore.*/
+module Disposable: {
+  /**The type representing a `Disposable`.*/
+  type t
+
+  /**Dispose the `Disposable`.*/
+  @send
+  external dispose: t => unit = "dispose"
+
+  /**Ignore this disposable.*/ external ignore: t => unit = "%ignore"
+}
+
+/**A required field logger, which gets called when a field annotated with the @required directive was missing from the response*/
+module RequiredFieldLogger: {
+  type kind = [#"missing_field.log" | #"missing_field.throw"]
+
+  /**A required field logger, which gets called when a field annotated with the @required directive was missing from the response*/
+  type t = (~kind: kind, ~owner: string, ~fieldPath: string) => unit
+}
+
+/**Module representing the environment, which you'll need to use and pass to various functions. Takes a few configuration options like store and network layer.*/
+module Environment: {
+  /**The type representing an instantiated `Environment`.*/
+  type t
+
+  /**Create a new `Environment`.*/
+  let make: (
+    ~network: Network.t,
+    ~store: Store.t,
+    ~getDataID: (
+      ~nodeObj: {.."__typename": string, "id": string} as 'a,
+      ~typeName: string,
+    ) => string=?,
+    ~treatMissingFieldsAsNull: bool=?,
+    ~missingFieldHandlers: array<MissingFieldHandler.t>=?,
+    ~requiredFieldLogger: RequiredFieldLogger.t=?,
+    ~isServer: bool=?,
+    unit,
+  ) => t
+
+  /**Get the `Store` for this `Environment`.*/
+  @send
+  external getStore: t => Store.t = "getStore"
+
+  /**Given an `operationDescriptor`, commits the corresponding payload.*/
+  @send
+  external commitPayload: (t, operationDescriptor, 'payload) => unit = "commitPayload"
+
+  /**Given an `operationDescriptor`, retains the corresponding operation so any data referenced by it isn't garbage collected.
+You should use the generated `Query.retain` function on your queries instead of using this directly.*/
+  @send
+  external retain: (t, operationDescriptor) => Disposable.t = "retain"
+}
+
+/**fetchPolicy controls how you want Relay to resolve your data.*/
+type fetchPolicy =
+  | /** will only reuse locally cached data, and will never send a network request to fetch the query. In this case, the responsibility of fetching the query falls to the caller, but this policy could also be used to read and operate on data that is entirely local. */
+  @as("store-only")
+  StoreOnly
+  | /** (default) will reuse locally cached data, and will only send a network request if any data for the query is missing or stale. If the query is fully cached, a network request will not be made.*/
+  @as("store-or-network")
+  StoreOrNetwork
+  | /** will reuse locally cached data and will always send a network request, regardless of whether any data was missing or stale in the store. */
+  @as("store-and-network")
+  StoreAndNetwork
+  | /** will not reuse locally cached data, and will always send a network request to fetch the query, ignoring any data that might be locally cached and whether it's missing or stale. */
+  @as("network-only")
+  NetworkOnly
+
+/**The fetch policies allowed for fetching a query outside of React's render (as in `Query.fetch`).*/
+type fetchQueryFetchPolicy =
+  | /** will not reuse locally cached data, and will always send a network request to fetch the query, ignoring any data that might be locally cached and whether it's missing or stale. */
+  @as("network-only")
+  NetworkOnly
+  | /** (default) will reuse locally cached data, and will only send a network request if any data for the query is missing or stale. If the query is fully cached, a network request will not be made.*/
+  @as("store-or-network")
+  StoreOrNetwork
+
+/**An error from a mutation.*/
+type mutationError = {message: string}
+
+/**Context provider for the Relay environment.*/
+module Context: {
+  /**Type representing the context.*/
+  type t
+
+  /**The expected shape of the context.*/
+  type contextShape = {"environment": Environment.t}
+
+  /**The actual React context coming from Relay.*/
+  @module("react-relay")
+  external context: React.Context.t<option<contextShape>> = "ReactRelayContext"
+
+  /**The context provider you wrap your app in and pass your `Environment` for Relay to work.*/
+  module Provider: {
+    /**The React component you wrap your app in and pass your `Environment` for Relay to work.*/
+    type props<'environment, 'children> = {
+      environment: 'environment,
+      children: 'children,
+    }
+    let make: props<Environment.t, React.element> => React.element
+  }
+}
+
+/**An exception saying that the environment could not be found in the context. Means you forgot to wrap your app in `<RescriptRelay.Context.Provider environment=RelayEnv.environment>`*/
+exception EnvironmentNotFoundInContext
+
+/**Hook for getting the current environment from context.*/
+let useEnvironmentFromContext: unit => Environment.t
+
+/**An exception detailing that a mutation failed.*/ exception Mutation_failed(array<mutationError>)
+
+/**A way of committing a local update to the store.*/
+@module("relay-runtime")
+external commitLocalUpdate: (
+  ~environment: Environment.t,
+  ~updater: RecordSourceSelectorProxy.t => unit,
+) => unit = "commitLocalUpdate"
+
+/**Allows you to subscribe to when a record, connection, or even the store itself is invalidated, and then react to that.*/
+@module("react-relay")
+external useSubscribeToInvalidationState: (array<dataId>, unit => unit) => Disposable.t =
+  "useSubscribeToInvalidationState"
+
+/**Options valid when fetching a query outside of React's render method (like when using `Query.fetch`).*/
+type fetchQueryOptions = {
+  networkCacheConfig?: cacheConfig,
+  fetchPolicy?: fetchPolicy,
+}
+
+module type MakeLoadQueryConfig = {
+  type variables
+  type loadedQueryRef
+  type response
+  type node
+  let query: queryNode<node>
+  let convertVariables: variables => variables
+}
+
+module MakeLoadQuery: (C: MakeLoadQueryConfig) =>
+{
+  let load: (
+    ~environment: Environment.t,
+    ~variables: C.variables,
+    ~fetchPolicy: fetchPolicy=?,
+    ~fetchKey: string=?,
+    ~networkCacheConfig: cacheConfig=?,
+    unit,
+  ) => C.loadedQueryRef
+
+  let queryRefToObservable: C.loadedQueryRef => option<Observable.t<C.response>>
+  let queryRefToPromise: C.loadedQueryRef => Js.Promise.t<Belt.Result.t<unit, unit>>
+}
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmi b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmi
new file mode 100644
index 0000000..d8d7548
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmj b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmj
new file mode 100644
index 0000000..2f96ba4
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmt b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmt
new file mode 100644
index 0000000..fa85238
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmti b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmti
new file mode 100644
index 0000000..3735892
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.res b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.res
new file mode 100644
index 0000000..ac6ab5e
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.res
@@ -0,0 +1,91 @@
+open RescriptRelay
+
+let resolveNestedRecord = (
+  ~rootRecord: option<RescriptRelay.RecordProxy.t>,
+  ~path: list<string>,
+) => {
+  let currentRecord = ref(rootRecord)
+  let pathLength = List.length(path)
+
+  switch pathLength {
+  | 0 => ()
+  | _ =>
+    for i in 0 to pathLength - 1 {
+      let currentPath = path->Belt.List.get(i)
+      switch (currentRecord.contents, currentPath) {
+      | (Some(record), Some(currentPath)) =>
+        currentRecord := record->RescriptRelay.RecordProxy.getLinkedRecord(~name=currentPath, ())
+      | _ => currentRecord := None
+      }
+    }
+  }
+
+  currentRecord.contents
+}
+
+let resolveNestedRecordFromRoot = (~store, ~path: list<string>) =>
+  switch path {
+  | list{} => None
+  | list{rootRecordPath} =>
+    switch store->RescriptRelay.RecordSourceSelectorProxy.getRootField(~fieldName=rootRecordPath) {
+    | Some(rootRecord) => Some(rootRecord)
+    | None => None
+    }
+  | list{rootRecordPath, ...restPath} =>
+    resolveNestedRecord(
+      ~rootRecord=store->RescriptRelay.RecordSourceSelectorProxy.getRootField(
+        ~fieldName=rootRecordPath,
+      ),
+      ~path=restPath,
+    )
+  }
+
+type insertAt =
+  | Start
+  | End
+
+type connectionConfig = {
+  parentID: dataId,
+  key: string,
+  filters: option<RescriptRelay.arguments>,
+}
+
+let removeNodeFromConnections = (~store, ~node, ~connections) =>
+  connections->Belt.List.forEach(connectionConfig =>
+    switch store->RecordSourceSelectorProxy.get(~dataId=connectionConfig.parentID) {
+    | Some(owner) =>
+      switch ConnectionHandler.getConnection(
+        ~record=owner,
+        ~key=connectionConfig.key,
+        ~filters=?connectionConfig.filters,
+        (),
+      ) {
+      | Some(connection) =>
+        ConnectionHandler.deleteNode(~connection, ~nodeId=node->RecordProxy.getDataId)
+      | None => ()
+      }
+    | None => ()
+    }
+  )
+
+let createAndAddEdgeToConnections = (~store, ~node, ~connections, ~edgeName, ~insertAt) =>
+  connections->Belt.List.forEach(connectionConfig =>
+    switch store->RecordSourceSelectorProxy.get(~dataId=connectionConfig.parentID) {
+    | Some(connectionOwner) =>
+      switch ConnectionHandler.getConnection(
+        ~record=connectionOwner,
+        ~key=connectionConfig.key,
+        ~filters=?connectionConfig.filters,
+        (),
+      ) {
+      | Some(connection) =>
+        let edge = ConnectionHandler.createEdge(~store, ~connection, ~node, ~edgeType=edgeName)
+        switch insertAt {
+        | Start => ConnectionHandler.insertEdgeAfter(~connection, ~newEdge=edge, ())
+        | End => ConnectionHandler.insertEdgeBefore(~connection, ~newEdge=edge, ())
+        }
+      | None => ()
+      }
+    | None => ()
+    }
+  )
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.resi b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.resi
new file mode 100644
index 0000000..dc03e0e
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelayUtils.resi
@@ -0,0 +1,36 @@
+/**Tries to return a record from a nested path of linked records.*/
+let resolveNestedRecord: (
+  ~rootRecord: option<RescriptRelay.RecordProxy.t>,
+  ~path: list<string>,
+) => option<RescriptRelay.RecordProxy.t>
+
+/**Tries to return a record from a nested path of linked records, starting from the root.*/
+let resolveNestedRecordFromRoot: (
+  ~store: RescriptRelay.RecordSourceSelectorProxy.t,
+  ~path: list<string>,
+) => option<RescriptRelay.RecordProxy.t>
+
+/**Helpers for handling connections.*/
+type insertAt =
+  | Start
+  | End
+
+type connectionConfig = {
+  parentID: RescriptRelay.dataId,
+  key: string,
+  filters: option<RescriptRelay.arguments>,
+}
+
+let removeNodeFromConnections: (
+  ~store: RescriptRelay.RecordSourceSelectorProxy.t,
+  ~node: RescriptRelay.RecordProxy.t,
+  ~connections: list<connectionConfig>,
+) => unit
+
+let createAndAddEdgeToConnections: (
+  ~store: RescriptRelay.RecordSourceSelectorProxy.t,
+  ~node: RescriptRelay.RecordProxy.t,
+  ~connections: list<connectionConfig>,
+  ~edgeName: string,
+  ~insertAt: insertAt,
+) => unit
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmi
new file mode 100644
index 0000000..298f228
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmj b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmj
new file mode 100644
index 0000000..05f1b6b
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmt b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmt
new file mode 100644
index 0000000..47dbf9f
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmti b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmti
new file mode 100644
index 0000000..919376f
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.res b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.res
new file mode 100644
index 0000000..562e4d6
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.res
@@ -0,0 +1,239 @@
+open RescriptRelay
+
+@module("react-relay")
+external useFragment_: (fragmentNode<'node>, 'fragmentRef) => 'fragment = "useFragment"
+
+let useFragment = (~node, ~convertFragment: 'fragment => 'fragment, ~fRef) => {
+  /** React hook for getting the data of this fragment. Pass \
+                     the `fragmentRefs` of any object where you've spread your \
+                     fragment into this and get the fragment data back.\n\n\
+                     ### Fragment data outside of React's render\n\
+                     If you're looking for a way to use fragments _outside_ of \
+                     render (for regular function calls for instance, like for \
+                     logging etc), look in to adding `@inline` to your \
+                     fragment definition (like `fragment SomeFragment_user on \
+                     User @inline {...}`) and then use `Fragment.readInline`. \
+                     This will allow you to get the fragment data, but outside \
+                     of React's render.*/
+  (
+    useFragment_(node, fRef)
+    ->(RescriptRelay_Internal.internal_useConvertedValue(convertFragment, _))
+  )
+}
+
+@module("react-relay")
+external useFragmentOpt_: (fragmentNode<'node>, option<'fragmentRef>) => Js.Nullable.t<'fragment> =
+  "useFragment"
+
+let useFragmentOpt = (~fRef, ~node, ~convertFragment: 'fragment => 'fragment) => {
+  // TODO(v11) can convert to Nullable pattern match.
+
+  /** A version of `Fragment.use` that'll allow you to pass \
+                     `option<fragmentRefs>` and get `option<'fragmentData>` \
+                     back. Useful for scenarios where you don't have the \
+                     fragmentRefs yet.*/
+  let data =
+    useFragmentOpt_(node, fRef)->Js.Nullable.toOption
+  React.useMemo1(() => {
+    switch data {
+    | Some(data) => Some(convertFragment(data))
+    | None => None
+    }
+  }, [data])
+}
+
+@module("react-relay")
+external readInlineData_: (fragmentNode<'node>, 'fragmentRef) => 'fragment = "readInlineData"
+
+let readInlineData = (~node, ~convertFragment: 'fragment => 'fragment, ~fRef) => {
+  /** This lets you get the data for this fragment _outside \
+                       of React's render_. Useful for letting functions with \
+                       with fragments too, for things like logging etc.*/
+  (readInlineData_(node, fRef)->convertFragment)
+}
+
+type refetchableFnOpts = {
+  fetchPolicy?: fetchPolicy,
+  onComplete?: Js.Nullable.t<Js.Exn.t> => unit,
+}
+
+let internal_makeRefetchableFnOpts = (~fetchPolicy=?, ~onComplete=?, ()) => {
+  ?fetchPolicy,
+  onComplete: ?onComplete->RescriptRelay_Internal.internal_nullableToOptionalExnHandler,
+}
+
+type paginationLoadMoreOptions = {onComplete?: Js.Nullable.t<Js.Exn.t> => unit}
+type paginationLoadMoreFn = (
+  ~count: int,
+  ~onComplete: option<Js.Exn.t> => unit=?,
+  unit,
+) => Disposable.t
+type paginationFragmentReturnRaw<'fragment, 'refetchVariables> = {
+  data: 'fragment,
+  loadNext: (int, paginationLoadMoreOptions) => Disposable.t,
+  loadPrevious: (int, paginationLoadMoreOptions) => Disposable.t,
+  hasNext: bool,
+  hasPrevious: bool,
+  isLoadingNext: bool,
+  isLoadingPrevious: bool,
+  refetch: ('refetchVariables, refetchableFnOpts) => Disposable.t,
+}
+type paginationBlockingFragmentReturn<'fragment, 'refetchVariables> = {
+  data: 'fragment,
+  loadNext: paginationLoadMoreFn,
+  loadPrevious: paginationLoadMoreFn,
+  hasNext: bool,
+  hasPrevious: bool,
+  refetch: (
+    ~variables: 'refetchVariables,
+    ~fetchPolicy: fetchPolicy=?,
+    ~onComplete: option<Js.Exn.t> => unit=?,
+    unit,
+  ) => Disposable.t,
+}
+type paginationFragmentReturn<'fragment, 'refetchVariables> = {
+  data: 'fragment,
+  loadNext: paginationLoadMoreFn,
+  loadPrevious: paginationLoadMoreFn,
+  hasNext: bool,
+  hasPrevious: bool,
+  isLoadingNext: bool,
+  isLoadingPrevious: bool,
+  refetch: (
+    ~variables: 'refetchVariables,
+    ~fetchPolicy: fetchPolicy=?,
+    ~onComplete: option<Js.Exn.t> => unit=?,
+    unit,
+  ) => Disposable.t,
+}
+
+@module("react-relay")
+external usePaginationFragment_: (
+  fragmentNode<'node>,
+  'fragmentRef,
+) => paginationFragmentReturnRaw<'fragment, 'refetchVariables> = "usePaginationFragment"
+
+/** React hook for paginating a fragment. Paginating with \
+                       this hook will _not_ cause your component to suspend. \
+                       If you want pagination to trigger suspense, look into \
+                       using `Fragment.useBlockingPagination`.*/
+let usePaginationFragment = (
+  ~node,
+  ~fRef,
+  ~convertFragment: 'fragment => 'fragment,
+  ~convertRefetchVariables: 'refetchVariables => 'refetchVariables,
+) => {
+  let p = usePaginationFragment_(node, fRef)
+  let data = RescriptRelay_Internal.internal_useConvertedValue(convertFragment, p.data)
+  {
+    data,
+    loadNext: React.useMemo1(() => (~count, ~onComplete=?, ()) => {
+      p.loadNext(
+        count,
+        {onComplete: ?onComplete->RescriptRelay_Internal.internal_nullableToOptionalExnHandler},
+      )
+    }, [p.loadNext]),
+    loadPrevious: React.useMemo1(() => (~count, ~onComplete=?, ()) => {
+      p.loadPrevious(
+        count,
+        {onComplete: ?onComplete->RescriptRelay_Internal.internal_nullableToOptionalExnHandler},
+      )
+    }, [p.loadPrevious]),
+    hasNext: p.hasNext,
+    hasPrevious: p.hasPrevious,
+    isLoadingNext: p.isLoadingNext,
+    isLoadingPrevious: p.isLoadingPrevious,
+    refetch: React.useMemo1(() => (~variables, ~fetchPolicy=?, ~onComplete=?, ()) => {
+      p.refetch(
+        RescriptRelay_Internal.internal_cleanObjectFromUndefinedRaw(
+          variables->convertRefetchVariables,
+        ),
+        internal_makeRefetchableFnOpts(~onComplete?, ~fetchPolicy?, ()),
+      )
+    }, [p.refetch]),
+  }
+}
+
+@module("react-relay/lib/relay-hooks/useBlockingPaginationFragment")
+external useBlockingPaginationFragment_: (
+  fragmentNode<'node>,
+  'fragmentRef,
+) => paginationFragmentReturnRaw<'fragment, 'refetchVariables> = "default"
+
+/** Like `Fragment.usePagination`, but calling the \
+                       pagination function will trigger suspense. Useful for \
+                       all-at-once pagination.*/
+let useBlockingPaginationFragment = (
+  ~node,
+  ~fRef,
+  ~convertFragment: 'fragment => 'fragment,
+  ~convertRefetchVariables: 'refetchVariables => 'refetchVariables,
+) => {
+  let p = useBlockingPaginationFragment_(node, fRef)
+  let data = RescriptRelay_Internal.internal_useConvertedValue(convertFragment, p.data)
+  {
+    data,
+    loadNext: React.useMemo1(() => (~count, ~onComplete=?, ()) => {
+      p.loadNext(
+        count,
+        {onComplete: ?onComplete->RescriptRelay_Internal.internal_nullableToOptionalExnHandler},
+      )
+    }, [p.loadNext]),
+    loadPrevious: React.useMemo1(() => (~count, ~onComplete=?, ()) => {
+      p.loadPrevious(
+        count,
+        {onComplete: ?onComplete->RescriptRelay_Internal.internal_nullableToOptionalExnHandler},
+      )
+    }, [p.loadPrevious]),
+    hasNext: p.hasNext,
+    hasPrevious: p.hasPrevious,
+    refetch: React.useMemo1(() => (~variables, ~fetchPolicy=?, ~onComplete=?, ()) => {
+      p.refetch(
+        RescriptRelay_Internal.internal_cleanObjectFromUndefinedRaw(
+          variables->convertRefetchVariables,
+        ),
+        internal_makeRefetchableFnOpts(~onComplete?, ~fetchPolicy?, ()),
+      )
+    }, [p.refetch]),
+  }
+}
+
+@module("react-relay")
+external useRefetchableFragment_: (
+  fragmentNode<'node>,
+  'fragmentRef,
+) => ('fragment, ('refetchVariables, refetchableFnOpts) => Disposable.t) = "useRefetchableFragment"
+
+/**React hook for using a fragment that you want to refetch. Returns \
+             a tuple of `(fragmentData, refetchFn)`.\n\n\
+             ### Refetching and variables\n\
+             You supply a _diff_ of your variables to Relay when refetching. \
+             Diffed variables here means that any new value you supply when \
+             refetching will be merged with the variables you last used when \
+             fetching data for this fragment.\n\n\
+             ### `Fragment.makeRefetchVariables` - helper for making the \
+             refetch variables\n\
+             There's a helper generated for you to create those diffed \
+             variables more easily at `Fragment.makeRefetchVariables`.*/
+let useRefetchableFragment = (
+  ~node,
+  ~convertFragment: 'fragment => 'fragment,
+  ~convertRefetchVariables: 'refetchVariables => 'refetchVariables,
+  ~fRef,
+) => {
+  let (fragmentData, refetchFn) = useRefetchableFragment_(node, fRef)
+  let data = RescriptRelay_Internal.internal_useConvertedValue(convertFragment, fragmentData)
+  (
+    data,
+    React.useMemo1(
+      () => (~variables: 'refetchVariables, ~fetchPolicy=?, ~onComplete=?, ()) =>
+        refetchFn(
+          RescriptRelay_Internal.internal_removeUndefinedAndConvertNullsRaw(
+            variables->convertRefetchVariables,
+          ),
+          internal_makeRefetchableFnOpts(~fetchPolicy?, ~onComplete?, ()),
+        ),
+      [refetchFn],
+    ),
+  )
+}
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.resi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.resi
new file mode 100644
index 0000000..9bd5933
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Fragment.resi
@@ -0,0 +1,86 @@
+open RescriptRelay
+
+let useFragment: (
+  ~node: fragmentNode<'a>,
+  ~convertFragment: 'fragment => 'fragment,
+  ~fRef: 'b,
+) => 'fragment
+
+let useFragmentOpt: (
+  ~fRef: option<'a>,
+  ~node: fragmentNode<'b>,
+  ~convertFragment: 'fragment => 'fragment,
+) => option<'fragment>
+
+let readInlineData: (
+  ~node: fragmentNode<'a>,
+  ~convertFragment: 'fragment => 'fragment,
+  ~fRef: 'b,
+) => 'fragment
+
+type paginationLoadMoreOptions = {onComplete?: Js.Nullable.t<Js.Exn.t> => unit}
+
+type paginationLoadMoreFn = (
+  ~count: int,
+  ~onComplete: option<Js.Exn.t> => unit=?,
+  unit,
+) => Disposable.t
+
+type paginationBlockingFragmentReturn<'fragment, 'refetchVariables> = {
+  data: 'fragment,
+  loadNext: paginationLoadMoreFn,
+  loadPrevious: paginationLoadMoreFn,
+  hasNext: bool,
+  hasPrevious: bool,
+  refetch: (
+    ~variables: 'refetchVariables,
+    ~fetchPolicy: fetchPolicy=?,
+    ~onComplete: option<Js.Exn.t> => unit=?,
+    unit,
+  ) => Disposable.t,
+}
+
+type paginationFragmentReturn<'fragment, 'refetchVariables> = {
+  data: 'fragment,
+  loadNext: paginationLoadMoreFn,
+  loadPrevious: paginationLoadMoreFn,
+  hasNext: bool,
+  hasPrevious: bool,
+  isLoadingNext: bool,
+  isLoadingPrevious: bool,
+  refetch: (
+    ~variables: 'refetchVariables,
+    ~fetchPolicy: fetchPolicy=?,
+    ~onComplete: option<Js.Exn.t> => unit=?,
+    unit,
+  ) => Disposable.t,
+}
+
+let usePaginationFragment: (
+  ~node: fragmentNode<'a>,
+  ~fRef: 'b,
+  ~convertFragment: 'fragment => 'fragment,
+  ~convertRefetchVariables: 'refetchVariables => 'refetchVariables,
+) => paginationFragmentReturn<'fragment, 'refetchVariables>
+
+let useBlockingPaginationFragment: (
+  ~node: fragmentNode<'a>,
+  ~fRef: 'b,
+  ~convertFragment: 'fragment => 'fragment,
+  ~convertRefetchVariables: 'refetchVariables => 'refetchVariables,
+) => paginationBlockingFragmentReturn<'fragment, 'refetchVariables>
+
+let useRefetchableFragment: (
+  ~node: fragmentNode<'a>,
+  ~convertFragment: 'fragment => 'fragment,
+  ~convertRefetchVariables: 'refetchVariables => 'refetchVariables,
+  ~fRef: 'b,
+) => (
+  'fragment,
+  (
+    ~variables: 'refetchVariables,
+    ~fetchPolicy: fetchPolicy=?,
+    ~onComplete: option<Js.Exn.t> => unit=?,
+    unit,
+  ) => Disposable.t,
+)
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmi
new file mode 100644
index 0000000..bada84b
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmj b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmj
new file mode 100644
index 0000000..0082c1f
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmt b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmt
new file mode 100644
index 0000000..571805e
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmti b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmti
new file mode 100644
index 0000000..91347d6
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.res b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.res
new file mode 100644
index 0000000..e47d437
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.res
@@ -0,0 +1,37 @@
+let internal_keepMapFieldsRaw = (record, f) =>
+  record
+  ->Obj.magic
+  ->Belt.Option.map(obj => obj->Js.Dict.entries->Belt.Array.keepMap(f)->Js.Dict.fromArray)
+  ->Obj.magic
+
+// we need to do this until we can use @obj on record types
+// see https://github.com/rescript-lang/rescript-compiler/pull/5253
+let internal_cleanObjectFromUndefinedRaw = record =>
+  switch internal_keepMapFieldsRaw(record, ((key, value)) => {
+    switch value {
+    | Some(value) => Some((key, value))
+    | None => None
+    }
+  }) {
+  | None => /* Relay expects an empty object, not undefined */ %raw(json`{}`)
+  | Some(v) => v
+  }
+
+let internal_removeUndefinedAndConvertNullsRaw = record =>
+  internal_keepMapFieldsRaw(record, ((key, value)) => {
+    switch (value, value == Some(None)) {
+    | (Some(value), _) => Some((key, Js.Nullable.return(value)))
+    | (_, true) => Some((key, Js.Nullable.null))
+    | (None, _) => None
+    }
+  })
+
+let internal_useConvertedValue = (convert, v) => React.useMemo1(() => convert(v), [v])
+
+let internal_nullableToOptionalExnHandler = x =>
+  switch x {
+  | None => None
+  | Some(handler) => Some(maybeExn => maybeExn->Js.Nullable.toOption->handler)
+  }
+
+@live @unboxed type rec arg = Arg(_): arg
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.resi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.resi
new file mode 100644
index 0000000..fd294b1
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Internal.resi
@@ -0,0 +1,7 @@
+let internal_useConvertedValue: ('a => 'a, 'a) => 'a
+let internal_cleanObjectFromUndefinedRaw: 't => 't
+let internal_removeUndefinedAndConvertNullsRaw: 't => 't
+let internal_nullableToOptionalExnHandler: option<option<'b> => 'a> => option<
+  Js.Nullable.t<'b> => 'a,
+>
+@live @unboxed type rec arg = Arg(_): arg
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmi
new file mode 100644
index 0000000..8161755
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmj b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmj
new file mode 100644
index 0000000..63c016d
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmt b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmt
new file mode 100644
index 0000000..4d4e546
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmti b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmti
new file mode 100644
index 0000000..ee6caeb
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.res b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.res
new file mode 100644
index 0000000..7cdab7a
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.res
@@ -0,0 +1,146 @@
+open RescriptRelay
+
+type updaterFn<'response> = (RecordSourceSelectorProxy.t, 'response) => unit
+type optimisticUpdaterFn = RecordSourceSelectorProxy.t => unit
+type useMutationConfig<'response, 'rawResponse, 'variables> = {
+  onError?: mutationError => unit,
+  onCompleted?: ('response, option<array<mutationError>>) => unit,
+  onUnsubscribe?: unit => unit,
+  optimisticResponse?: 'rawResponse,
+  optimisticUpdater?: optimisticUpdaterFn,
+  updater?: updaterFn<'response>,
+  variables: 'variables,
+  uploadables?: uploadables,
+}
+
+type commitMutationConfigRaw<'m, 'variables, 'response, 'rawResponse> = {
+  mutation: mutationNode<'m>,
+  variables: 'variables,
+  onCompleted?: ('response, Js.Nullable.t<array<mutationError>>) => unit,
+  onError?: mutationError => unit,
+  optimisticResponse?: 'rawResponse,
+  optimisticUpdater?: optimisticUpdaterFn,
+  updater?: updaterFn<'response>,
+  uploadables?: uploadables,
+}
+
+type useMutationConfigRaw<'m, 'variables, 'response, 'rawResponse> = {
+  onError?: mutationError => unit,
+  onCompleted?: ('response, Js.Nullable.t<array<mutationError>>) => unit,
+  onUnsubscribe?: unit => unit,
+  optimisticResponse?: 'rawResponse,
+  optimisticUpdater?: optimisticUpdaterFn,
+  updater?: updaterFn<'response>,
+  variables: 'variables,
+  uploadables?: uploadables,
+}
+
+@module("relay-runtime")
+external commitMutation_: (
+  Environment.t,
+  commitMutationConfigRaw<'m, 'variables, 'response, 'rawResponse>,
+) => Disposable.t = "commitMutation"
+
+@module("react-relay")
+external useMutation_: 'm => (
+  useMutationConfigRaw<'m, 'variables, 'response, 'rawResponse> => Disposable.t,
+  bool,
+) = "useMutation"
+
+let commitMutation = (
+  ~convertVariables: 'variables => 'variables,
+  ~node: 'm,
+  ~convertResponse: 'response => 'response,
+  ~convertWrapRawResponse: 'rawResponse => 'rawResponse,
+) => {
+  /**Commits the current mutation. Use this outside of React's \
+               render. If you're inside render, you should use `Mutation.use` \
+               instead, which is more convenient.\n\n\
+               ### Optimistic updates\n\
+               Remember to annotate your mutation with `@raw_response_type` if \
+               you want to do optimistic updates. That'll make Relay emit the \
+               required type information for covering everything needed when \
+               doing optimistic updates.*/
+  (
+    ~environment: Environment.t,
+    ~variables: 'variables,
+    ~optimisticUpdater=?,
+    ~optimisticResponse: option<'rawResponse>=?,
+    ~updater=?,
+    ~onCompleted=?,
+    ~onError=?,
+    ~uploadables=?,
+    (),
+  ) => {
+    commitMutation_(
+      environment,
+      {
+        mutation: node,
+        onCompleted: ?switch onCompleted {
+        | Some(cb) => Some((res, err) => cb(res->convertResponse, err->Js.Nullable.toOption))
+        | None => None
+        },
+        ?onError,
+        optimisticResponse: ?switch optimisticResponse {
+        | Some(optimisticResponse) => Some(optimisticResponse->convertWrapRawResponse)
+        | None => None
+        },
+        ?optimisticUpdater,
+        updater: ?switch updater {
+        | Some(updater) => Some((store, response) => updater(store, response->convertResponse))
+        | None => None
+        },
+        ?uploadables,
+        variables: variables->convertVariables,
+      },
+    )
+  }
+}
+
+let useMutation = (
+  ~convertVariables: 'variables => 'variables,
+  ~node: 'm,
+  ~convertResponse: 'response => 'response,
+  ~convertWrapRawResponse: 'rawResponse => 'rawResponse,
+) => {
+  /**React hook for commiting this mutation.\n\n\
+               ### Optimistic updates\n\
+               Remember to annotate your mutation with `@raw_response_type` if \
+               you want to do optimistic updates. That'll make Relay emit the \
+               required type information for covering everything needed when \
+               doing optimistic updates.*/
+  () => {
+    let (mutate, mutating) = useMutation_(node)
+    (React.useMemo1(() => {
+        (
+          ~variables: 'variables,
+          ~optimisticUpdater=?,
+          ~optimisticResponse: option<'rawResponse>=?,
+          ~updater=?,
+          ~onCompleted=?,
+          ~onError=?,
+          ~uploadables=?,
+          (),
+        ) => {
+          mutate({
+            onCompleted: ?switch onCompleted {
+            | Some(cb) => Some((res, err) => cb(res->convertResponse, err->Js.Nullable.toOption))
+            | None => None
+            },
+            ?onError,
+            optimisticResponse: ?switch optimisticResponse {
+            | Some(optimisticResponse) => Some(optimisticResponse->convertWrapRawResponse)
+            | None => None
+            },
+            ?optimisticUpdater,
+            updater: ?switch updater {
+            | Some(updater) => Some((store, response) => updater(store, response->convertResponse))
+            | None => None
+            },
+            ?uploadables,
+            variables: variables->convertVariables,
+          })
+        }
+      }, [mutate]), mutating)
+  }
+}
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.resi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.resi
new file mode 100644
index 0000000..73ec5c8
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Mutation.resi
@@ -0,0 +1,54 @@
+/*** Internal file, do not use directly.*/
+
+open RescriptRelay
+
+type updaterFn<'response> = (RecordSourceSelectorProxy.t, 'response) => unit
+type optimisticUpdaterFn = RecordSourceSelectorProxy.t => unit
+
+@live
+type useMutationConfig<'response, 'rawResponse, 'variables> = {
+  onError?: mutationError => unit,
+  onCompleted?: ('response, option<array<mutationError>>) => unit,
+  onUnsubscribe?: unit => unit,
+  optimisticResponse?: 'rawResponse,
+  optimisticUpdater?: optimisticUpdaterFn,
+  updater?: updaterFn<'response>,
+  variables: 'variables,
+  uploadables?: uploadables,
+}
+
+let commitMutation: (
+  ~convertVariables: 'variables => 'variables,
+  ~node: mutationNode<'a>,
+  ~convertResponse: 'response => 'response,
+  ~convertWrapRawResponse: 'rawResponse => 'rawResponse,
+) => (
+  ~environment: Environment.t,
+  ~variables: 'variables,
+  ~optimisticUpdater: optimisticUpdaterFn=?,
+  ~optimisticResponse: 'rawResponse=?,
+  ~updater: (RecordSourceSelectorProxy.t, 'response) => unit=?,
+  ~onCompleted: ('response, option<array<mutationError>>) => unit=?,
+  ~onError: mutationError => unit=?,
+  ~uploadables: uploadables=?,
+  unit,
+) => Disposable.t
+
+let useMutation: (
+  ~convertVariables: 'variables => 'variables,
+  ~node: mutationNode<'node>,
+  ~convertResponse: 'response => 'response,
+  ~convertWrapRawResponse: 'rawResponse => 'rawResponse,
+) => unit => (
+  (
+    ~variables: 'variables,
+    ~optimisticUpdater: optimisticUpdaterFn=?,
+    ~optimisticResponse: 'rawResponse=?,
+    ~updater: (RecordSourceSelectorProxy.t, 'response) => unit=?,
+    ~onCompleted: ('response, option<array<mutationError>>) => unit=?,
+    ~onError: mutationError => unit=?,
+    ~uploadables: uploadables=?,
+    unit,
+  ) => Disposable.t,
+  bool,
+)
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmi
new file mode 100644
index 0000000..a7480e9
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmj b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmj
new file mode 100644
index 0000000..0f71dab
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmt b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmt
new file mode 100644
index 0000000..817ea75
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmti b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmti
new file mode 100644
index 0000000..5a013c6
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.res b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.res
new file mode 100644
index 0000000..2e8ac8e
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.res
@@ -0,0 +1,185 @@
+open RescriptRelay
+
+type useQueryConfig = {
+  fetchKey?: string,
+  fetchPolicy?: fetchPolicy,
+  networkCacheConfig?: cacheConfig,
+}
+
+@module("react-relay")
+external useLazyLoadQuery: (queryNode<'node>, 'variables, useQueryConfig) => 'response =
+  "useLazyLoadQuery"
+
+let useQuery = (
+  ~convertVariables: 'variables => 'variables,
+  ~node: 'm,
+  ~convertResponse: 'response => 'response,
+) => {
+  /**
+    React hook for using this query.\n\n\
+                Prefer using `Query.useLoader()` or \
+                `YourQueryName_graphql.load()` in combination with \
+                `Query.usePreloaded()` to this whenever you can, as that will \
+                allow you to start loading data before your code actually \
+                renders.*/
+  (~variables: 'variables, ~fetchPolicy=?, ~fetchKey=?, ~networkCacheConfig=?, ()) => {
+    useLazyLoadQuery(
+      node,
+      RescriptRelay_Internal.internal_cleanObjectFromUndefinedRaw(variables->convertVariables),
+      {
+        ?fetchKey,
+        ?fetchPolicy,
+        ?networkCacheConfig,
+      },
+    )->(RescriptRelay_Internal.internal_useConvertedValue(convertResponse, _))
+  }
+}
+
+type useQueryLoaderOptions = {
+  fetchPolicy?: fetchPolicy,
+  networkCacheConfig?: cacheConfig,
+}
+
+@module("react-relay")
+external useQueryLoader: queryNode<'node> => (
+  Js.Nullable.t<'queryRef>,
+  ('variables, useQueryLoaderOptions) => unit,
+  unit => unit,
+) = "useQueryLoader"
+
+let useLoader = (
+  ~convertVariables: 'variables => 'variables,
+  ~node: 'm,
+  ~mkQueryRef: option<'queryRef> => option<'queryRef>,
+) => {
+  () => {
+    let (nullableQueryRef, loadQueryFn, disposableFn) = useQueryLoader(node)
+    let loadQuery = React.useMemo1(
+      () => (~variables, ~fetchPolicy=?, ~networkCacheConfig=?, ()) =>
+        loadQueryFn(variables->convertVariables, {?fetchPolicy, ?networkCacheConfig}),
+      [loadQueryFn],
+    )
+    (nullableQueryRef->Js.Nullable.toOption->mkQueryRef, loadQuery, disposableFn)
+  }
+}
+
+@module("react-relay")
+external usePreloadedQuery: (queryNode<'node>, 'queryRef) => 'response = "usePreloadedQuery"
+
+let usePreloaded = (
+  ~node,
+  ~convertResponse: 'response => 'response,
+  ~mkQueryRef: 'queryRef => 'queryRef,
+) => /** Combine this with `Query.useLoader` or \
+                `YourQueryName_graphql.load()` to use a query you've started \
+                preloading before rendering. */
+(~queryRef: 'queryRef) => {
+  usePreloadedQuery(node, queryRef->mkQueryRef)->(
+    RescriptRelay_Internal.internal_useConvertedValue(convertResponse, _)
+  )
+}
+
+@module("react-relay")
+external fetchQuery: (
+  Environment.t,
+  queryNode<'node>,
+  'variables,
+  option<fetchQueryOptions>,
+) => Observable.t<'response> = "fetchQuery"
+
+let fetch = (
+  ~node,
+  ~convertResponse: 'response => 'response,
+  ~convertVariables: 'variables => 'variables,
+) => {
+  /**\n\
+                This fetches the query in a one-off fashion, and returns a \
+                `Belt.Result.t` in a callback for convenience. Use \
+                `Query.fetchPromised` if you need this but with promises.\n\n\
+                Please *avoid* using `Query.fetch` unless you really need it, \
+                since the data you fetch here isn't guaranteed to stick around \
+                in the store/cache unless you explicitly use it somewhere in \
+                your views.*/
+  (
+    ~environment: Environment.t,
+    ~variables: 'variables,
+    ~onResult,
+    ~networkCacheConfig=?,
+    ~fetchPolicy=?,
+    (),
+  ) => {
+    open Observable
+
+    fetchQuery(
+      environment,
+      node,
+      variables->convertVariables,
+      Some({?networkCacheConfig, ?fetchPolicy}),
+    )
+    ->subscribe(
+      makeObserver(
+        ~next=res => onResult(Ok(res->convertResponse)),
+        ~error=err => onResult(Error(err)),
+        (),
+      ),
+    )
+    ->ignoreSubscription
+  }
+}
+
+let fetchPromised = (
+  ~node,
+  ~convertResponse: 'response => 'response,
+  ~convertVariables: 'variables => 'variables,
+) => {
+  /**Promise variant of `Query.fetch`.*/
+  (
+    ~environment: Environment.t,
+    ~variables: 'variables,
+    ~networkCacheConfig=?,
+    ~fetchPolicy=?,
+    (),
+  ) => {
+    fetchQuery(
+      environment,
+      node,
+      variables->convertVariables,
+      Some({?networkCacheConfig, ?fetchPolicy}),
+    )
+    ->Observable.toPromise
+    ->Js.Promise2.then(res => res->convertResponse->Js.Promise2.resolve)
+  }
+}
+
+@module("relay-runtime")
+external createOperationDescriptor: (queryNode<'node>, 'variables) => operationDescriptor =
+  "createOperationDescriptor"
+
+let retain = (~node, ~convertVariables: 'variables => 'variables) => {
+  /**Calling with a set of variables will make Relay _disable \
+                garbage collection_ of this query (+ variables) until you \
+                explicitly dispose the `Disposable.t` you get back from this \
+                call.\n\n\
+                Useful for queries and data you know you want to keep in the \
+                store regardless of what happens (like it not being used by \
+                any view and therefore potentially garbage collected).*/
+  (~environment: Environment.t, ~variables: 'variables) => {
+    environment->Environment.retain(createOperationDescriptor(node, variables->convertVariables))
+  }
+}
+
+let commitLocalPayload = (
+  ~node,
+  ~convertVariables: 'variables => 'variables,
+  ~convertWrapRawResponse: 'rawResponse => 'rawResponse,
+) => {
+  /** This commits a payload into the store _locally only_. Useful \
+                  for driving client-only state via Relay for example, or \
+                  priming the cache with data you don't necessarily want to \
+                  hit the server for. */
+  (~environment: Environment.t, ~variables: 'variables, ~payload: 'rawResponse) =>
+    environment->Environment.commitPayload(
+      createOperationDescriptor(node, variables->convertVariables),
+      payload->convertWrapRawResponse,
+    )
+}
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.resi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.resi
new file mode 100644
index 0000000..bca0201
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Query.resi
@@ -0,0 +1,70 @@
+open RescriptRelay
+
+let useQuery: (
+  ~convertVariables: 'variables => 'variables,
+  ~node: queryNode<'a>,
+  ~convertResponse: 'response => 'response,
+) => (
+  ~variables: 'variables,
+  ~fetchPolicy: fetchPolicy=?,
+  ~fetchKey: string=?,
+  ~networkCacheConfig: cacheConfig=?,
+  unit,
+) => 'response
+
+let useLoader: (
+  ~convertVariables: 'variables => 'variables,
+  ~node: queryNode<'a>,
+  ~mkQueryRef: option<'queryRef> => option<'queryRef>,
+) => unit => (
+  option<'queryRef>,
+  (
+    ~variables: 'variables,
+    ~fetchPolicy: fetchPolicy=?,
+    ~networkCacheConfig: cacheConfig=?,
+    unit,
+  ) => unit,
+  unit => unit,
+)
+
+let usePreloaded: (
+  ~node: queryNode<'a>,
+  ~convertResponse: 'response => 'response,
+  ~mkQueryRef: 'queryRef => 'queryRef,
+) => (~queryRef: 'queryRef) => 'response
+
+let fetch: (
+  ~node: queryNode<'a>,
+  ~convertResponse: 'response => 'response,
+  ~convertVariables: 'variables => 'variables,
+) => (
+  ~environment: Environment.t,
+  ~variables: 'variables,
+  ~onResult: result<'response, Js.Exn.t> => unit,
+  ~networkCacheConfig: cacheConfig=?,
+  ~fetchPolicy: fetchPolicy=?,
+  unit,
+) => unit
+
+let fetchPromised: (
+  ~node: queryNode<'a>,
+  ~convertResponse: 'response => 'response,
+  ~convertVariables: 'variables => 'variables,
+) => (
+  ~environment: Environment.t,
+  ~variables: 'variables,
+  ~networkCacheConfig: cacheConfig=?,
+  ~fetchPolicy: fetchPolicy=?,
+  unit,
+) => promise<'response>
+
+let retain: (
+  ~node: queryNode<'a>,
+  ~convertVariables: 'variables => 'variables,
+) => (~environment: Environment.t, ~variables: 'variables) => Disposable.t
+
+let commitLocalPayload: (
+  ~node: queryNode<'a>,
+  ~convertVariables: 'variables => 'variables,
+  ~convertWrapRawResponse: 'rawResponse => 'rawResponse,
+) => (~environment: Environment.t, ~variables: 'variables, ~payload: 'rawResponse) => unit
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmi
new file mode 100644
index 0000000..4d26d53
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmj b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmj
new file mode 100644
index 0000000..9c909af
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmt b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmt
new file mode 100644
index 0000000..f1ef608
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmti b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmti
new file mode 100644
index 0000000..995f898
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.res b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.res
new file mode 100644
index 0000000..751da78
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.res
@@ -0,0 +1,21 @@
+open RescriptRelay
+
+@module("relay-runtime/lib/store/ResolverFragments")
+external readFragment_: (fragmentNode<'node>, 'fragmentRef) => 'fragment = "readFragment"
+
+type resolver<'fragment, 't> = 'fragment => option<'t>
+
+// This is abstract just to hide the implementation details that don't need to be known anyway.
+type relayResolver
+external mkRelayResolver: 'a => relayResolver = "%identity"
+
+let makeRelayResolver = (
+  ~node,
+  ~convertFragment: 'fragment => 'fragment,
+  resolver: resolver<'fragment, 't>,
+) => {
+  let relayResolver = fRef => {
+    resolver(readFragment_(node, fRef)->convertFragment)
+  }
+  relayResolver->mkRelayResolver
+}
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.resi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.resi
new file mode 100644
index 0000000..76ac572
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_RelayResolvers.resi
@@ -0,0 +1,10 @@
+open RescriptRelay
+
+type resolver<'fragment, 't> = 'fragment => option<'t>
+type relayResolver
+
+let makeRelayResolver: (
+  ~node: fragmentNode<'a>,
+  ~convertFragment: 'fragment => 'fragment,
+  resolver<'fragment, 't>,
+) => relayResolver
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmi
new file mode 100644
index 0000000..20f504b
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmi differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmj b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmj
new file mode 100644
index 0000000..b143651
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmj differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmt b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmt
new file mode 100644
index 0000000..f8c2fc6
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmt differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmti b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmti
new file mode 100644
index 0000000..18680b1
Binary files /dev/null and b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.cmti differ
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.res b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.res
new file mode 100644
index 0000000..424fa54
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.res
@@ -0,0 +1,51 @@
+open RescriptRelay
+
+type updaterFn<'response> = (RecordSourceSelectorProxy.t, 'response) => unit
+type subscriptionConfig<'node, 'variables, 'response> = {
+  subscription: subscriptionNode<'node>,
+  variables: 'variables,
+  onCompleted?: unit => unit,
+  onError?: Js.Exn.t => unit,
+  onNext?: 'response => unit,
+  updater?: updaterFn<'response>,
+}
+
+@module("relay-runtime")
+external requestSubscription_: (
+  Environment.t,
+  subscriptionConfig<'node, 'variables, 'response>,
+) => Disposable.t = "requestSubscription"
+
+let subscribe = (
+  ~node,
+  ~convertVariables: 'variables => 'variables,
+  ~convertResponse: 'response => 'response,
+) => {
+  (
+    ~environment: Environment.t,
+    ~variables: 'variables,
+    ~onCompleted=?,
+    ~onError=?,
+    ~onNext=?,
+    ~updater=?,
+    (),
+  ) => {
+    requestSubscription_(
+      environment,
+      {
+        ?onCompleted,
+        subscription: node,
+        variables: variables->convertVariables,
+        ?onError,
+        onNext: ?switch onNext {
+        | Some(onNext) => Some(response => onNext(response->convertResponse))
+        | None => None
+        },
+        updater: ?switch updater {
+        | Some(updater) => Some((store, response) => updater(store, response->convertResponse))
+        | None => None
+        },
+      },
+    )
+  }
+}
diff --git a/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.resi b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.resi
new file mode 100644
index 0000000..40dcea6
--- /dev/null
+++ b/node_modules/rescript-relay/lib/ocaml/RescriptRelay_Subscriptions.resi
@@ -0,0 +1,15 @@
+open RescriptRelay
+
+let subscribe: (
+  ~node: subscriptionNode<'a>,
+  ~convertVariables: 'variables => 'variables,
+  ~convertResponse: 'response => 'response,
+) => (
+  ~environment: Environment.t,
+  ~variables: 'variables,
+  ~onCompleted: unit => unit=?,
+  ~onError: Js.Exn.t => unit=?,
+  ~onNext: 'response => unit=?,
+  ~updater: (RecordSourceSelectorProxy.t, 'response) => unit=?,
+  unit,
+) => Disposable.t
diff --git a/node_modules/rescript-relay/lib/ocaml/install.stamp b/node_modules/rescript-relay/lib/ocaml/install.stamp
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/rescript-relay/src/ReactDOMExperimental.mjs b/node_modules/rescript-relay/src/ReactDOMExperimental.mjs
new file mode 100644
index 0000000..0b461df
--- /dev/null
+++ b/node_modules/rescript-relay/src/ReactDOMExperimental.mjs
@@ -0,0 +1,24 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as ReactDOM from "@rescript/react/src/ReactDOM.mjs";
+import * as Client from "react-dom/client";
+
+function renderConcurrentRootAtElementWithId(content, id) {
+  var element = document.getElementById(id);
+  if (element == null) {
+    throw {
+          RE_EXN_ID: "Invalid_argument",
+          _1: "ReactExperimental.renderConcurrentRootAtElementWithId : no element of id " + id + " found in the HTML.",
+          Error: new Error()
+        };
+  }
+  Client.createRoot(element).render(content);
+}
+
+var Root = ReactDOM.Client.Root;
+
+export {
+  Root ,
+  renderConcurrentRootAtElementWithId ,
+}
+/* react-dom/client Not a pure module */
diff --git a/node_modules/rescript-relay/src/ReactExperimental.mjs b/node_modules/rescript-relay/src/ReactExperimental.mjs
new file mode 100644
index 0000000..bb03c89
--- /dev/null
+++ b/node_modules/rescript-relay/src/ReactExperimental.mjs
@@ -0,0 +1,24 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as React from "react";
+
+function useTransition(param) {
+  var match = React.useTransition();
+  var startTransition = match[1];
+  return [
+          match[0],
+          React.useMemo((function (param) {
+                  return function (cb) {
+                    return startTransition(cb, undefined);
+                  };
+                }), [startTransition])
+        ];
+}
+
+var SuspenseList = {};
+
+export {
+  useTransition ,
+  SuspenseList ,
+}
+/* react Not a pure module */
diff --git a/node_modules/rescript-relay/src/RescriptRelay.mjs b/node_modules/rescript-relay/src/RescriptRelay.mjs
new file mode 100644
index 0000000..3c63be3
--- /dev/null
+++ b/node_modules/rescript-relay/src/RescriptRelay.mjs
@@ -0,0 +1,256 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as Curry from "rescript/lib/es6/curry.js";
+import * as React from "react";
+import * as Utils from "./utils.mjs";
+import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
+import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
+import * as Caml_option from "rescript/lib/es6/caml_option.js";
+import * as ReactRelay from "react-relay";
+import * as RelayRuntime from "relay-runtime";
+import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
+
+function convertObj(prim0, prim1, prim2, prim3) {
+  return Utils.traverser(prim0, prim1, prim2, prim3);
+}
+
+function optArrayOfNullableToOptArrayOfOpt(x) {
+  if (x !== undefined) {
+    return Belt_Array.map(x, (function (prim) {
+      if (prim == null) {
+        return;
+      } else {
+        return Caml_option.some(prim);
+      }
+    }));
+  }
+
+}
+
+function getLinkedRecords(t, name, $$arguments, param) {
+  return optArrayOfNullableToOptArrayOfOpt(Caml_option.nullable_to_opt(t.getLinkedRecords(name, $$arguments)));
+}
+
+var RecordProxy = {
+  getLinkedRecords: getLinkedRecords
+};
+
+function getPluralRootField(t, fieldName) {
+  return optArrayOfNullableToOptArrayOfOpt(Caml_option.nullable_to_opt(t.getPluralRootField(fieldName)));
+}
+
+var RecordSourceSelectorProxy = {
+  getPluralRootField: getPluralRootField
+};
+
+var ReadOnlyRecordSourceProxy = {};
+
+function unwrapNormalizationArgument(wrapped) {
+  var match = wrapped.kind;
+  if (match === "Literal") {
+    return {
+      TAG: "Literal",
+      _0: wrapped
+    };
+  } else if (match === "ListValue") {
+    return {
+      TAG: "ListValue",
+      _0: wrapped
+    };
+  } else if (match === "ObjectValue") {
+    return {
+      TAG: "ObjectValue",
+      _0: wrapped
+    };
+  } else {
+    return {
+      TAG: "Variable",
+      _0: wrapped
+    };
+  }
+}
+
+function makeScalarMissingFieldHandler(handle) {
+  return {
+    kind: "scalar",
+    handle: handle
+  };
+}
+
+function makeLinkedMissingFieldHandler(handle) {
+  return {
+    kind: "linked",
+    handle: handle
+  };
+}
+
+function makePluralLinkedMissingFieldHandler(handle) {
+  return {
+    kind: "pluralLinked",
+    handle: handle
+  };
+}
+
+var MissingFieldHandler = {
+  unwrapNormalizationArgument: unwrapNormalizationArgument,
+  makeScalarMissingFieldHandler: makeScalarMissingFieldHandler,
+  makeLinkedMissingFieldHandler: makeLinkedMissingFieldHandler,
+  makePluralLinkedMissingFieldHandler: makePluralLinkedMissingFieldHandler
+};
+
+var nodeInterfaceMissingFieldHandler = makeLinkedMissingFieldHandler(function (field, record, args, _store) {
+  var match = field.name;
+  var match$1 = args.id;
+  if ((record == null) || !(match === "node" && record.getType() === RelayRuntime.ROOT_TYPE && !(match$1 == null))) {
+    return;
+  } else {
+    return Caml_option.some(match$1);
+  }
+});
+
+var ConnectionHandler = {};
+
+var Disposable = {};
+
+var Observable = {};
+
+var Network = {};
+
+var RecordSource = {};
+
+function make(source, gcReleaseBufferSize, queryCacheExpirationTime, param) {
+  return new RelayRuntime.Store(source, {
+    gcReleaseBufferSize: gcReleaseBufferSize,
+    queryCacheExpirationTime: queryCacheExpirationTime
+  });
+}
+
+var Store = {
+  make: make
+};
+
+function toJs(f, arg) {
+  Curry._3(f, arg.kind, arg.owner, arg.fieldPath);
+}
+
+function make$1(network, store, getDataID, treatMissingFieldsAsNull, missingFieldHandlers, requiredFieldLogger, isServer, param) {
+  var tmp = {
+    network: network,
+    store: store,
+    missingFieldHandlers: missingFieldHandlers !== undefined ? Belt_Array.concat(missingFieldHandlers, [nodeInterfaceMissingFieldHandler]) : [nodeInterfaceMissingFieldHandler]
+  };
+  if (getDataID !== undefined) {
+    tmp.getDataID = Caml_option.valFromOption(getDataID);
+  }
+  if (treatMissingFieldsAsNull !== undefined) {
+    tmp.treatMissingFieldsAsNull = Caml_option.valFromOption(treatMissingFieldsAsNull);
+  }
+  var tmp$1 = Belt_Option.map(requiredFieldLogger, toJs);
+  if (tmp$1 !== undefined) {
+    tmp.requiredFieldLogger = Caml_option.valFromOption(tmp$1);
+  }
+  if (isServer !== undefined) {
+    tmp.isServer = Caml_option.valFromOption(isServer);
+  }
+  return new RelayRuntime.Environment(tmp);
+}
+
+var Environment = {
+  make: make$1
+};
+
+function RescriptRelay$Context$Provider(props) {
+  var provider = ReactRelay.ReactRelayContext.Provider;
+  return React.createElement(provider, {
+    value: {
+      environment: props.environment
+    },
+    children: props.children
+  });
+}
+
+var Provider = {
+  make: RescriptRelay$Context$Provider
+};
+
+var Context = {
+  Provider: Provider
+};
+
+var EnvironmentNotFoundInContext = /* @__PURE__ */Caml_exceptions.create("RescriptRelay.EnvironmentNotFoundInContext");
+
+function useEnvironmentFromContext(param) {
+  var context = React.useContext(ReactRelay.ReactRelayContext);
+  if (context !== undefined) {
+    return Caml_option.valFromOption(context).environment;
+  }
+  throw {
+    RE_EXN_ID: EnvironmentNotFoundInContext,
+    Error: new Error()
+  };
+}
+
+function MakeLoadQuery(C) {
+  var load = function (environment, variables, fetchPolicy, fetchKey, networkCacheConfig, param) {
+    return ReactRelay.loadQuery(environment, C.query, Curry._1(C.convertVariables, variables), {
+      fetchKey: fetchKey,
+      fetchPolicy: fetchPolicy,
+      networkCacheConfig: networkCacheConfig
+    });
+  };
+  var queryRefToObservable = function (token) {
+    return Caml_option.nullable_to_opt(token.source);
+  };
+  var queryRefToPromise = function (token) {
+    return new Promise((function (resolve, param) {
+      var o = queryRefToObservable(token);
+      if (o !== undefined) {
+        Caml_option.valFromOption(o).subscribe({
+          complete: (function (param) {
+            resolve({
+              TAG: "Ok",
+              _0: undefined
+            });
+          })
+        });
+        return;
+      } else {
+        return resolve({
+          TAG: "Error",
+          _0: undefined
+        });
+      }
+    }));
+  };
+  return {
+    load: load,
+    queryRefToObservable: queryRefToObservable,
+    queryRefToPromise: queryRefToPromise
+  };
+}
+
+var Mutation_failed = /* @__PURE__ */Caml_exceptions.create("RescriptRelay.Mutation_failed");
+
+var RequiredFieldLogger = {};
+
+export {
+  convertObj,
+  RecordProxy,
+  RecordSourceSelectorProxy,
+  ReadOnlyRecordSourceProxy,
+  MissingFieldHandler,
+  ConnectionHandler,
+  Observable,
+  Network,
+  RecordSource,
+  Store,
+  Disposable,
+  RequiredFieldLogger,
+  Environment,
+  Context,
+  EnvironmentNotFoundInContext,
+  useEnvironmentFromContext,
+  Mutation_failed,
+  MakeLoadQuery,
+}
+/* nodeInterfaceMissingFieldHandler Not a pure module */
diff --git a/node_modules/rescript-relay/src/RescriptRelayUtils.mjs b/node_modules/rescript-relay/src/RescriptRelayUtils.mjs
new file mode 100644
index 0000000..038d633
--- /dev/null
+++ b/node_modules/rescript-relay/src/RescriptRelayUtils.mjs
@@ -0,0 +1,77 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as List from "rescript/lib/es6/list.js";
+import * as Belt_List from "rescript/lib/es6/belt_List.js";
+import * as Caml_option from "rescript/lib/es6/caml_option.js";
+import * as RelayRuntime from "relay-runtime";
+
+function resolveNestedRecord(rootRecord, path) {
+  var currentRecord = rootRecord;
+  var pathLength = List.length(path);
+  if (pathLength !== 0) {
+    for(var i = 0; i < pathLength; ++i){
+      var currentPath = Belt_List.get(path, i);
+      var match = currentRecord;
+      currentRecord = match !== undefined && currentPath !== undefined ? Caml_option.nullable_to_opt(Caml_option.valFromOption(match).getLinkedRecord(currentPath, undefined)) : undefined;
+    }
+  }
+  return currentRecord;
+}
+
+function resolveNestedRecordFromRoot(store, path) {
+  if (!path) {
+    return ;
+  }
+  var restPath = path.tl;
+  var rootRecordPath = path.hd;
+  if (restPath) {
+    return resolveNestedRecord(Caml_option.nullable_to_opt(store.getRootField(rootRecordPath)), restPath);
+  }
+  var rootRecord = store.getRootField(rootRecordPath);
+  if (!(rootRecord == null)) {
+    return Caml_option.some(rootRecord);
+  }
+  
+}
+
+function removeNodeFromConnections(store, node, connections) {
+  Belt_List.forEach(connections, (function (connectionConfig) {
+          var owner = store.get(connectionConfig.parentID);
+          if (owner == null) {
+            return ;
+          }
+          var connection = RelayRuntime.ConnectionHandler.getConnection(owner, connectionConfig.key, connectionConfig.filters !== undefined ? Caml_option.valFromOption(connectionConfig.filters) : undefined);
+          if (!(connection == null)) {
+            RelayRuntime.ConnectionHandler.deleteNode(connection, node.getDataID());
+            return ;
+          }
+          
+        }));
+}
+
+function createAndAddEdgeToConnections(store, node, connections, edgeName, insertAt) {
+  Belt_List.forEach(connections, (function (connectionConfig) {
+          var connectionOwner = store.get(connectionConfig.parentID);
+          if (connectionOwner == null) {
+            return ;
+          }
+          var connection = RelayRuntime.ConnectionHandler.getConnection(connectionOwner, connectionConfig.key, connectionConfig.filters !== undefined ? Caml_option.valFromOption(connectionConfig.filters) : undefined);
+          if (connection == null) {
+            return ;
+          }
+          var edge = RelayRuntime.ConnectionHandler.createEdge(store, connection, node, edgeName);
+          if (insertAt === "Start") {
+            RelayRuntime.ConnectionHandler.insertEdgeAfter(connection, edge, undefined);
+            return ;
+          }
+          RelayRuntime.ConnectionHandler.insertEdgeBefore(connection, edge, undefined);
+        }));
+}
+
+export {
+  resolveNestedRecord ,
+  resolveNestedRecordFromRoot ,
+  removeNodeFromConnections ,
+  createAndAddEdgeToConnections ,
+}
+/* relay-runtime Not a pure module */
diff --git a/node_modules/rescript-relay/src/RescriptRelay_Fragment.mjs b/node_modules/rescript-relay/src/RescriptRelay_Fragment.mjs
new file mode 100644
index 0000000..5a153c0
--- /dev/null
+++ b/node_modules/rescript-relay/src/RescriptRelay_Fragment.mjs
@@ -0,0 +1,119 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as Curry from "rescript/lib/es6/curry.js";
+import * as React from "react";
+import * as Caml_option from "rescript/lib/es6/caml_option.js";
+import * as ReactRelay from "react-relay";
+import * as RescriptRelay_Internal from "./RescriptRelay_Internal.mjs";
+import UseBlockingPaginationFragment from "react-relay/lib/relay-hooks/useBlockingPaginationFragment";
+
+function useFragment(node, convertFragment, fRef) {
+  return RescriptRelay_Internal.internal_useConvertedValue(convertFragment, ReactRelay.useFragment(node, fRef));
+}
+
+function useFragmentOpt(fRef, node, convertFragment) {
+  var data = ReactRelay.useFragment(node, fRef);
+  return React.useMemo((function (param) {
+                if (!(data == null)) {
+                  return Caml_option.some(Curry._1(convertFragment, data));
+                }
+                
+              }), [(data == null) ? undefined : Caml_option.some(data)]);
+}
+
+function readInlineData(node, convertFragment, fRef) {
+  return Curry._1(convertFragment, ReactRelay.readInlineData(node, fRef));
+}
+
+function usePaginationFragment(node, fRef, convertFragment, convertRefetchVariables) {
+  var p = ReactRelay.usePaginationFragment(node, fRef);
+  var data = RescriptRelay_Internal.internal_useConvertedValue(convertFragment, p.data);
+  return {
+          data: data,
+          loadNext: React.useMemo((function (param) {
+                  return function (count, onComplete, param) {
+                    return Curry._2(p.loadNext, count, {
+                                onComplete: RescriptRelay_Internal.internal_nullableToOptionalExnHandler(onComplete)
+                              });
+                  };
+                }), [p.loadNext]),
+          loadPrevious: React.useMemo((function (param) {
+                  return function (count, onComplete, param) {
+                    return Curry._2(p.loadPrevious, count, {
+                                onComplete: RescriptRelay_Internal.internal_nullableToOptionalExnHandler(onComplete)
+                              });
+                  };
+                }), [p.loadPrevious]),
+          hasNext: p.hasNext,
+          hasPrevious: p.hasPrevious,
+          isLoadingNext: p.isLoadingNext,
+          isLoadingPrevious: p.isLoadingPrevious,
+          refetch: React.useMemo((function (param) {
+                  return function (variables, fetchPolicy, onComplete, param) {
+                    return Curry._2(p.refetch, RescriptRelay_Internal.internal_cleanObjectFromUndefinedRaw(Curry._1(convertRefetchVariables, variables)), {
+                                fetchPolicy: fetchPolicy,
+                                onComplete: RescriptRelay_Internal.internal_nullableToOptionalExnHandler(onComplete)
+                              });
+                  };
+                }), [p.refetch])
+        };
+}
+
+function useBlockingPaginationFragment(node, fRef, convertFragment, convertRefetchVariables) {
+  var p = UseBlockingPaginationFragment(node, fRef);
+  var data = RescriptRelay_Internal.internal_useConvertedValue(convertFragment, p.data);
+  return {
+          data: data,
+          loadNext: React.useMemo((function (param) {
+                  return function (count, onComplete, param) {
+                    return Curry._2(p.loadNext, count, {
+                                onComplete: RescriptRelay_Internal.internal_nullableToOptionalExnHandler(onComplete)
+                              });
+                  };
+                }), [p.loadNext]),
+          loadPrevious: React.useMemo((function (param) {
+                  return function (count, onComplete, param) {
+                    return Curry._2(p.loadPrevious, count, {
+                                onComplete: RescriptRelay_Internal.internal_nullableToOptionalExnHandler(onComplete)
+                              });
+                  };
+                }), [p.loadPrevious]),
+          hasNext: p.hasNext,
+          hasPrevious: p.hasPrevious,
+          refetch: React.useMemo((function (param) {
+                  return function (variables, fetchPolicy, onComplete, param) {
+                    return Curry._2(p.refetch, RescriptRelay_Internal.internal_cleanObjectFromUndefinedRaw(Curry._1(convertRefetchVariables, variables)), {
+                                fetchPolicy: fetchPolicy,
+                                onComplete: RescriptRelay_Internal.internal_nullableToOptionalExnHandler(onComplete)
+                              });
+                  };
+                }), [p.refetch])
+        };
+}
+
+function useRefetchableFragment(node, convertFragment, convertRefetchVariables, fRef) {
+  var match = ReactRelay.useRefetchableFragment(node, fRef);
+  var refetchFn = match[1];
+  var data = RescriptRelay_Internal.internal_useConvertedValue(convertFragment, match[0]);
+  return [
+          data,
+          React.useMemo((function (param) {
+                  return function (variables, fetchPolicy, onComplete, param) {
+                    return Curry._2(refetchFn, RescriptRelay_Internal.internal_removeUndefinedAndConvertNullsRaw(Curry._1(convertRefetchVariables, variables)), {
+                                fetchPolicy: fetchPolicy,
+                                onComplete: RescriptRelay_Internal.internal_nullableToOptionalExnHandler(onComplete)
+                              });
+                  };
+                }), [refetchFn])
+        ];
+}
+
+export {
+  useFragment ,
+  useFragmentOpt ,
+  readInlineData ,
+  usePaginationFragment ,
+  useBlockingPaginationFragment ,
+  useRefetchableFragment ,
+}
+/* react Not a pure module */
diff --git a/node_modules/rescript-relay/src/RescriptRelay_Internal.mjs b/node_modules/rescript-relay/src/RescriptRelay_Internal.mjs
new file mode 100644
index 0000000..9eda80b
--- /dev/null
+++ b/node_modules/rescript-relay/src/RescriptRelay_Internal.mjs
@@ -0,0 +1,77 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as Curry from "rescript/lib/es6/curry.js";
+import * as React from "react";
+import * as Js_dict from "rescript/lib/es6/js_dict.js";
+import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
+import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
+import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
+import * as Caml_option from "rescript/lib/es6/caml_option.js";
+
+function internal_keepMapFieldsRaw(record, f) {
+  return Belt_Option.map(record, (function (obj) {
+                return Js_dict.fromArray(Belt_Array.keepMap(Js_dict.entries(obj), f));
+              }));
+}
+
+function internal_cleanObjectFromUndefinedRaw(record) {
+  var v = internal_keepMapFieldsRaw(record, (function (param) {
+          var value = param[1];
+          if (value !== undefined) {
+            return [
+                    param[0],
+                    Caml_option.valFromOption(value)
+                  ];
+          }
+          
+        }));
+  if (v !== undefined) {
+    return Caml_option.valFromOption(v);
+  } else {
+    return {};
+  }
+}
+
+function internal_removeUndefinedAndConvertNullsRaw(record) {
+  return internal_keepMapFieldsRaw(record, (function (param) {
+                var value = param[1];
+                var key = param[0];
+                var match = Caml_obj.equal(value, Caml_option.some(undefined));
+                if (value !== undefined) {
+                  return [
+                          key,
+                          Caml_option.valFromOption(value)
+                        ];
+                } else if (match) {
+                  return [
+                          key,
+                          null
+                        ];
+                } else {
+                  return ;
+                }
+              }));
+}
+
+function internal_useConvertedValue(convert, v) {
+  return React.useMemo((function (param) {
+                return Curry._1(convert, v);
+              }), [v]);
+}
+
+function internal_nullableToOptionalExnHandler(x) {
+  if (x !== undefined) {
+    return (function (maybeExn) {
+              return Curry._1(x, (maybeExn == null) ? undefined : Caml_option.some(maybeExn));
+            });
+  }
+  
+}
+
+export {
+  internal_useConvertedValue ,
+  internal_cleanObjectFromUndefinedRaw ,
+  internal_removeUndefinedAndConvertNullsRaw ,
+  internal_nullableToOptionalExnHandler ,
+}
+/* react Not a pure module */
diff --git a/node_modules/rescript-relay/src/RescriptRelay_Mutation.mjs b/node_modules/rescript-relay/src/RescriptRelay_Mutation.mjs
new file mode 100644
index 0000000..b72035f
--- /dev/null
+++ b/node_modules/rescript-relay/src/RescriptRelay_Mutation.mjs
@@ -0,0 +1,55 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as Curry from "rescript/lib/es6/curry.js";
+import * as React from "react";
+import * as Caml_option from "rescript/lib/es6/caml_option.js";
+import * as ReactRelay from "react-relay";
+import * as RelayRuntime from "relay-runtime";
+
+function commitMutation(convertVariables, node, convertResponse, convertWrapRawResponse, environment, variables, optimisticUpdater, optimisticResponse, updater, onCompleted, onError, uploadables, param) {
+  return RelayRuntime.commitMutation(environment, {
+              mutation: node,
+              variables: Curry._1(convertVariables, variables),
+              onCompleted: onCompleted !== undefined ? (function (res, err) {
+                    Curry._2(onCompleted, Curry._1(convertResponse, res), (err == null) ? undefined : Caml_option.some(err));
+                  }) : undefined,
+              onError: onError,
+              optimisticResponse: optimisticResponse !== undefined ? Caml_option.some(Curry._1(convertWrapRawResponse, Caml_option.valFromOption(optimisticResponse))) : undefined,
+              optimisticUpdater: optimisticUpdater,
+              updater: updater !== undefined ? (function (store, response) {
+                    Curry._2(updater, store, Curry._1(convertResponse, response));
+                  }) : undefined,
+              uploadables: uploadables
+            });
+}
+
+function useMutation(convertVariables, node, convertResponse, convertWrapRawResponse, param) {
+  var match = ReactRelay.useMutation(node);
+  var mutate = match[0];
+  return [
+          React.useMemo((function (param) {
+                  return function (variables, optimisticUpdater, optimisticResponse, updater, onCompleted, onError, uploadables, param) {
+                    return Curry._1(mutate, {
+                                onError: onError,
+                                onCompleted: onCompleted !== undefined ? (function (res, err) {
+                                      Curry._2(onCompleted, Curry._1(convertResponse, res), (err == null) ? undefined : Caml_option.some(err));
+                                    }) : undefined,
+                                optimisticResponse: optimisticResponse !== undefined ? Caml_option.some(Curry._1(convertWrapRawResponse, Caml_option.valFromOption(optimisticResponse))) : undefined,
+                                optimisticUpdater: optimisticUpdater,
+                                updater: updater !== undefined ? (function (store, response) {
+                                      Curry._2(updater, store, Curry._1(convertResponse, response));
+                                    }) : undefined,
+                                variables: Curry._1(convertVariables, variables),
+                                uploadables: uploadables
+                              });
+                  };
+                }), [mutate]),
+          match[1]
+        ];
+}
+
+export {
+  commitMutation ,
+  useMutation ,
+}
+/* react Not a pure module */
diff --git a/node_modules/rescript-relay/src/RescriptRelay_Query.mjs b/node_modules/rescript-relay/src/RescriptRelay_Query.mjs
new file mode 100644
index 0000000..72137f6
--- /dev/null
+++ b/node_modules/rescript-relay/src/RescriptRelay_Query.mjs
@@ -0,0 +1,87 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as Curry from "rescript/lib/es6/curry.js";
+import * as React from "react";
+import * as Caml_option from "rescript/lib/es6/caml_option.js";
+import * as Js_promise2 from "rescript/lib/es6/js_promise2.js";
+import ReactRelay from "react-relay";
+import * as RelayRuntime from "relay-runtime";
+import * as RescriptRelay_Internal from "./RescriptRelay_Internal.mjs";
+
+function useQuery(convertVariables, node, convertResponse, variables, fetchPolicy, fetchKey, networkCacheConfig, param) {
+  return RescriptRelay_Internal.internal_useConvertedValue(convertResponse, ReactRelay.useLazyLoadQuery(node, RescriptRelay_Internal.internal_cleanObjectFromUndefinedRaw(Curry._1(convertVariables, variables)), {
+    fetchKey: fetchKey,
+    fetchPolicy: fetchPolicy,
+    networkCacheConfig: networkCacheConfig
+  }));
+}
+
+function useLoader(convertVariables, node, mkQueryRef, param) {
+  var match = ReactRelay.useQueryLoader(node);
+  var loadQueryFn = match[1];
+  var loadQuery = React.useMemo((function (param) {
+    return function (variables, fetchPolicy, networkCacheConfig, param) {
+      return Curry._2(loadQueryFn, Curry._1(convertVariables, variables), {
+        fetchPolicy: fetchPolicy,
+        networkCacheConfig: networkCacheConfig
+      });
+    };
+  }), [loadQueryFn]);
+  return [
+    Curry._1(mkQueryRef, Caml_option.nullable_to_opt(match[0])),
+    loadQuery,
+    match[2]
+  ];
+}
+
+function usePreloaded(node, convertResponse, mkQueryRef, queryRef) {
+  return RescriptRelay_Internal.internal_useConvertedValue(convertResponse, ReactRelay.usePreloadedQuery(node, Curry._1(mkQueryRef, queryRef)));
+}
+
+function $$fetch(node, convertResponse, convertVariables, environment, variables, onResult, networkCacheConfig, fetchPolicy, param) {
+  ReactRelay.fetchQuery(environment, node, Curry._1(convertVariables, variables), {
+    networkCacheConfig: networkCacheConfig,
+    fetchPolicy: fetchPolicy
+  }).subscribe({
+    next: (function (res) {
+      Curry._1(onResult, {
+        TAG: "Ok",
+        _0: Curry._1(convertResponse, res)
+      });
+    }),
+    error: (function (err) {
+      Curry._1(onResult, {
+        TAG: "Error",
+        _0: err
+      });
+    })
+  });
+}
+
+function fetchPromised(node, convertResponse, convertVariables, environment, variables, networkCacheConfig, fetchPolicy, param) {
+  return Js_promise2.then(ReactRelay.fetchQuery(environment, node, Curry._1(convertVariables, variables), {
+    networkCacheConfig: networkCacheConfig,
+    fetchPolicy: fetchPolicy
+  }).toPromise(), (function (res) {
+    return Promise.resolve(Curry._1(convertResponse, res));
+  }));
+}
+
+function retain(node, convertVariables, environment, variables) {
+  return environment.retain(RelayRuntime.createOperationDescriptor(node, Curry._1(convertVariables, variables)));
+}
+
+function commitLocalPayload(node, convertVariables, convertWrapRawResponse, environment, variables, payload) {
+  environment.commitPayload(RelayRuntime.createOperationDescriptor(node, Curry._1(convertVariables, variables)), Curry._1(convertWrapRawResponse, payload));
+}
+
+export {
+  useQuery,
+  useLoader,
+  usePreloaded,
+  $$fetch,
+  fetchPromised,
+  retain,
+  commitLocalPayload,
+}
+/* react Not a pure module */
diff --git a/node_modules/rescript-relay/src/RescriptRelay_RelayResolvers.mjs b/node_modules/rescript-relay/src/RescriptRelay_RelayResolvers.mjs
new file mode 100644
index 0000000..bbb7fa4
--- /dev/null
+++ b/node_modules/rescript-relay/src/RescriptRelay_RelayResolvers.mjs
@@ -0,0 +1,15 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as Curry from "rescript/lib/es6/curry.js";
+import * as ResolverFragments from "relay-runtime/lib/store/ResolverFragments";
+
+function makeRelayResolver(node, convertFragment, resolver) {
+  return function (fRef) {
+    return Curry._1(resolver, Curry._1(convertFragment, ResolverFragments.readFragment(node, fRef)));
+  };
+}
+
+export {
+  makeRelayResolver ,
+}
+/* relay-runtime/lib/store/ResolverFragments Not a pure module */
diff --git a/node_modules/rescript-relay/src/RescriptRelay_Subscriptions.mjs b/node_modules/rescript-relay/src/RescriptRelay_Subscriptions.mjs
new file mode 100644
index 0000000..4744664
--- /dev/null
+++ b/node_modules/rescript-relay/src/RescriptRelay_Subscriptions.mjs
@@ -0,0 +1,24 @@
+// Generated by ReScript, PLEASE EDIT WITH CARE
+
+import * as Curry from "rescript/lib/es6/curry.js";
+import * as RelayRuntime from "relay-runtime";
+
+function subscribe(node, convertVariables, convertResponse, environment, variables, onCompleted, onError, onNext, updater, param) {
+  return RelayRuntime.requestSubscription(environment, {
+              subscription: node,
+              variables: Curry._1(convertVariables, variables),
+              onCompleted: onCompleted,
+              onError: onError,
+              onNext: onNext !== undefined ? (function (response) {
+                    Curry._1(onNext, Curry._1(convertResponse, response));
+                  }) : undefined,
+              updater: updater !== undefined ? (function (store, response) {
+                    Curry._2(updater, store, Curry._1(convertResponse, response));
+                  }) : undefined
+            });
+}
+
+export {
+  subscribe ,
+}
+/* relay-runtime Not a pure module */
